// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "wit": Application User Types
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-wit/design
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-wit
// --version=v1.3.0

package client

import (
	"github.com/goadesign/goa"
	uuid "github.com/goadesign/goa/uuid"
	"time"
	"unicode/utf8"
)

// JSONAPI store for the data of a Area. See also http://jsonapi.org/format/#document-resource-object
type area struct {
	Attributes *areaAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of area
	ID            *uuid.UUID     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *areaRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string        `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the area type instance.
func (ut *area) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "areas") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"areas"}))
		}
	}
	return
}

// Publicize creates Area from area
func (ut *area) Publicize() *Area {
	var pub Area
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Area. See also http://jsonapi.org/format/#document-resource-object
type Area struct {
	Attributes *AreaAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of area
	ID            *uuid.UUID     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *AreaRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string         `form:"type" json:"type" xml:"type"`
}

// Validate validates the Area type instance.
func (ut *Area) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "areas") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"areas"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Area. See also see http://jsonapi.org/format/#document-resource-object-attributes
type areaAttributes struct {
	// When the area was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Area name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Human-friendly number of the area that is unique inside the area's space
	Number *int `form:"number,omitempty" json:"number,omitempty" xml:"number,omitempty"`
	// Path to the topmost parent
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path to the topmost area specified by area names
	ParentPathResolved *string `form:"parent_path_resolved,omitempty" json:"parent_path_resolved,omitempty" xml:"parent_path_resolved,omitempty"`
	// When the area was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the areaAttributes type instance.
func (ut *areaAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Publicize creates AreaAttributes from areaAttributes
func (ut *areaAttributes) Publicize() *AreaAttributes {
	var pub AreaAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Number != nil {
		pub.Number = ut.Number
	}
	if ut.ParentPath != nil {
		pub.ParentPath = ut.ParentPath
	}
	if ut.ParentPathResolved != nil {
		pub.ParentPathResolved = ut.ParentPathResolved
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Area. See also see http://jsonapi.org/format/#document-resource-object-attributes
type AreaAttributes struct {
	// When the area was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Area name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Human-friendly number of the area that is unique inside the area's space
	Number *int `form:"number,omitempty" json:"number,omitempty" xml:"number,omitempty"`
	// Path to the topmost parent
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path to the topmost area specified by area names
	ParentPathResolved *string `form:"parent_path_resolved,omitempty" json:"parent_path_resolved,omitempty" xml:"parent_path_resolved,omitempty"`
	// When the area was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the AreaAttributes type instance.
func (ut *AreaAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// areaRelations user type.
type areaRelations struct {
	// This defines the sub-areas present for this area
	Children *relationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines the parents' hierarchy for areas
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the Area
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Publicize creates AreaRelations from areaRelations
func (ut *areaRelations) Publicize() *AreaRelations {
	var pub AreaRelations
	if ut.Children != nil {
		pub.Children = ut.Children.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	return &pub
}

// AreaRelations user type.
type AreaRelations struct {
	// This defines the sub-areas present for this area
	Children *RelationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines the parents' hierarchy for areas
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the Area
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// backlogGenericLink user type.
type backlogGenericLink struct {
	Meta *backlogLinkMeta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string          `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the backlogGenericLink type instance.
func (ut *backlogGenericLink) Validate() (err error) {
	if ut.Meta != nil {
		if err2 := ut.Meta.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates BacklogGenericLink from backlogGenericLink
func (ut *backlogGenericLink) Publicize() *BacklogGenericLink {
	var pub BacklogGenericLink
	if ut.Meta != nil {
		pub.Meta = ut.Meta.Publicize()
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// BacklogGenericLink user type.
type BacklogGenericLink struct {
	Meta *BacklogLinkMeta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string          `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// backlogLinkMeta user type.
type backlogLinkMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the backlogLinkMeta type instance.
func (ut *backlogLinkMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates BacklogLinkMeta from backlogLinkMeta
func (ut *backlogLinkMeta) Publicize() *BacklogLinkMeta {
	var pub BacklogLinkMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// BacklogLinkMeta user type.
type BacklogLinkMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// baseTypeData user type.
type baseTypeData struct {
	// ID of the work item type
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the baseTypeData type instance.
func (ut *baseTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates BaseTypeData from baseTypeData
func (ut *baseTypeData) Publicize() *BaseTypeData {
	var pub BaseTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// BaseTypeData user type.
type BaseTypeData struct {
	// ID of the work item type
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the BaseTypeData type instance.
func (ut *BaseTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// JSONAPI store for the data of a codebase.  See also http://jsonapi.org/format/#document-resource-object
type codebase struct {
	Attributes *codebaseAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of codebase
	ID            *uuid.UUID         `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *codebaseLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *codebaseRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string            `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the codebase type instance.
func (ut *codebase) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "codebases") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"codebases"}))
		}
	}
	return
}

// Publicize creates Codebase from codebase
func (ut *codebase) Publicize() *Codebase {
	var pub Codebase
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a codebase.  See also http://jsonapi.org/format/#document-resource-object
type Codebase struct {
	Attributes *CodebaseAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of codebase
	ID            *uuid.UUID         `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *CodebaseLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *CodebaseRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string             `form:"type" json:"type" xml:"type"`
}

// Validate validates the Codebase type instance.
func (ut *Codebase) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if !(ut.Type == "codebases") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"codebases"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a codebase. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type codebaseAttributes struct {
	// When the codebase was created
	CreatedAt *time.Time `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// Should this codebase be scanned for CVEs
	CveScan *bool `form:"cve-scan,omitempty" json:"cve-scan,omitempty" xml:"cve-scan,omitempty"`
	// The last used workspace name of the codebase
	LastUsedWorkspace *string `form:"last_used_workspace,omitempty" json:"last_used_workspace,omitempty" xml:"last_used_workspace,omitempty"`
	// The stack id of the codebase
	StackID *string `form:"stackId,omitempty" json:"stackId,omitempty" xml:"stackId,omitempty"`
	// The codebase type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The URL of the codebase
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Publicize creates CodebaseAttributes from codebaseAttributes
func (ut *codebaseAttributes) Publicize() *CodebaseAttributes {
	var pub CodebaseAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.CveScan != nil {
		pub.CveScan = ut.CveScan
	}
	if ut.LastUsedWorkspace != nil {
		pub.LastUsedWorkspace = ut.LastUsedWorkspace
	}
	if ut.StackID != nil {
		pub.StackID = ut.StackID
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a codebase. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CodebaseAttributes struct {
	// When the codebase was created
	CreatedAt *time.Time `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// Should this codebase be scanned for CVEs
	CveScan *bool `form:"cve-scan,omitempty" json:"cve-scan,omitempty" xml:"cve-scan,omitempty"`
	// The last used workspace name of the codebase
	LastUsedWorkspace *string `form:"last_used_workspace,omitempty" json:"last_used_workspace,omitempty" xml:"last_used_workspace,omitempty"`
	// The stack id of the codebase
	StackID *string `form:"stackId,omitempty" json:"stackId,omitempty" xml:"stackId,omitempty"`
	// The codebase type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The URL of the codebase
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// codebaseLinks user type.
type codebaseLinks struct {
	Edit    *string                `form:"edit,omitempty" json:"edit,omitempty" xml:"edit,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates CodebaseLinks from codebaseLinks
func (ut *codebaseLinks) Publicize() *CodebaseLinks {
	var pub CodebaseLinks
	if ut.Edit != nil {
		pub.Edit = ut.Edit
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// CodebaseLinks user type.
type CodebaseLinks struct {
	Edit    *string                `form:"edit,omitempty" json:"edit,omitempty" xml:"edit,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// codebaseListMeta user type.
type codebaseListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the codebaseListMeta type instance.
func (ut *codebaseListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates CodebaseListMeta from codebaseListMeta
func (ut *codebaseListMeta) Publicize() *CodebaseListMeta {
	var pub CodebaseListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// CodebaseListMeta user type.
type CodebaseListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// codebaseRelations user type.
type codebaseRelations struct {
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the dependent workspaces
	Workspaces *relationGeneric `form:"workspaces,omitempty" json:"workspaces,omitempty" xml:"workspaces,omitempty"`
}

// Publicize creates CodebaseRelations from codebaseRelations
func (ut *codebaseRelations) Publicize() *CodebaseRelations {
	var pub CodebaseRelations
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.Workspaces != nil {
		pub.Workspaces = ut.Workspaces.Publicize()
	}
	return &pub
}

// CodebaseRelations user type.
type CodebaseRelations struct {
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the dependent workspaces
	Workspaces *RelationGeneric `form:"workspaces,omitempty" json:"workspaces,omitempty" xml:"workspaces,omitempty"`
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type comment struct {
	Attributes *commentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of comment
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *commentRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string           `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the comment type instance.
func (ut *comment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "comments") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"comments"}))
		}
	}
	return
}

// Publicize creates Comment from comment
func (ut *comment) Publicize() *Comment {
	var pub Comment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type Comment struct {
	Attributes *CommentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of comment
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *CommentRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string            `form:"type" json:"type" xml:"type"`
}

// Validate validates the Comment type instance.
func (ut *Comment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "comments") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"comments"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type commentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment body rendered in HTML
	BodyRendered *string `form:"body.rendered,omitempty" json:"body.rendered,omitempty" xml:"body.rendered,omitempty"`
	// When the comment was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
	// When the comment was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Publicize creates CommentAttributes from commentAttributes
func (ut *commentAttributes) Publicize() *CommentAttributes {
	var pub CommentAttributes
	if ut.Body != nil {
		pub.Body = ut.Body
	}
	if ut.BodyRendered != nil {
		pub.BodyRendered = ut.BodyRendered
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Markup != nil {
		pub.Markup = ut.Markup
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CommentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment body rendered in HTML
	BodyRendered *string `form:"body.rendered,omitempty" json:"body.rendered,omitempty" xml:"body.rendered,omitempty"`
	// When the comment was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
	// When the comment was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// commentCreatedBy user type.
type commentCreatedBy struct {
	Data  *identityRelationData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the commentCreatedBy type instance.
func (ut *commentCreatedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CommentCreatedBy from commentCreatedBy
func (ut *commentCreatedBy) Publicize() *CommentCreatedBy {
	var pub CommentCreatedBy
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// CommentCreatedBy user type.
type CommentCreatedBy struct {
	Data  *IdentityRelationData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the CommentCreatedBy type instance.
func (ut *CommentCreatedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// commentListMeta user type.
type commentListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the commentListMeta type instance.
func (ut *commentListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates CommentListMeta from commentListMeta
func (ut *commentListMeta) Publicize() *CommentListMeta {
	var pub CommentListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// CommentListMeta user type.
type CommentListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// commentRelations user type.
type commentRelations struct {
	// DEPRECATED. This defines the creator of the comment.
	CreatedBy *commentCreatedBy `form:"created-by,omitempty" json:"created-by,omitempty" xml:"created-by,omitempty"`
	// This defines the creator of the comment
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment.
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the parent comment resource.
	ParentComment *relationGeneric `form:"parent-comment,omitempty" json:"parent-comment,omitempty" xml:"parent-comment,omitempty"`
}

// Validate validates the commentRelations type instance.
func (ut *commentRelations) Validate() (err error) {
	if ut.CreatedBy != nil {
		if err2 := ut.CreatedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CommentRelations from commentRelations
func (ut *commentRelations) Publicize() *CommentRelations {
	var pub CommentRelations
	if ut.CreatedBy != nil {
		pub.CreatedBy = ut.CreatedBy.Publicize()
	}
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.ParentComment != nil {
		pub.ParentComment = ut.ParentComment.Publicize()
	}
	return &pub
}

// CommentRelations user type.
type CommentRelations struct {
	// DEPRECATED. This defines the creator of the comment.
	CreatedBy *CommentCreatedBy `form:"created-by,omitempty" json:"created-by,omitempty" xml:"created-by,omitempty"`
	// This defines the creator of the comment
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment.
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the parent comment resource.
	ParentComment *RelationGeneric `form:"parent-comment,omitempty" json:"parent-comment,omitempty" xml:"parent-comment,omitempty"`
}

// Validate validates the CommentRelations type instance.
func (ut *CommentRelations) Validate() (err error) {
	if ut.CreatedBy != nil {
		if err2 := ut.CreatedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type createComment struct {
	Attributes    *createCommentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Relationships *createCommentRelations  `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                  `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createComment type instance.
func (ut *createComment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "comments") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"comments"}))
		}
	}
	return
}

// Publicize creates CreateComment from createComment
func (ut *createComment) Publicize() *CreateComment {
	var pub CreateComment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type CreateComment struct {
	Attributes    *CreateCommentAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Relationships *CreateCommentRelations  `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                   `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateComment type instance.
func (ut *CreateComment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "comments") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"comments"}))
	}
	return
}

// JSONAPI store for all the "attributes" for creating a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type createCommentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the createCommentAttributes type instance.
func (ut *createCommentAttributes) Validate() (err error) {
	if ut.Body == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "body"))
	}
	if ut.Body != nil {
		if utf8.RuneCountInString(*ut.Body) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.body`, *ut.Body, utf8.RuneCountInString(*ut.Body), 1, true))
		}
	}
	return
}

// Publicize creates CreateCommentAttributes from createCommentAttributes
func (ut *createCommentAttributes) Publicize() *CreateCommentAttributes {
	var pub CreateCommentAttributes
	if ut.Body != nil {
		pub.Body = *ut.Body
	}
	if ut.Markup != nil {
		pub.Markup = ut.Markup
	}
	return &pub
}

// JSONAPI store for all the "attributes" for creating a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CreateCommentAttributes struct {
	// The comment body
	Body string `form:"body" json:"body" xml:"body"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the CreateCommentAttributes type instance.
func (ut *CreateCommentAttributes) Validate() (err error) {
	if ut.Body == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "body"))
	}
	if utf8.RuneCountInString(ut.Body) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.body`, ut.Body, utf8.RuneCountInString(ut.Body), 1, true))
	}
	return
}

// createCommentRelations user type.
type createCommentRelations struct {
	// This defines the creator of the comment
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment.
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the parent comment resource.
	ParentComment *relationGeneric `form:"parent-comment,omitempty" json:"parent-comment,omitempty" xml:"parent-comment,omitempty"`
}

// Publicize creates CreateCommentRelations from createCommentRelations
func (ut *createCommentRelations) Publicize() *CreateCommentRelations {
	var pub CreateCommentRelations
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.ParentComment != nil {
		pub.ParentComment = ut.ParentComment.Publicize()
	}
	return &pub
}

// CreateCommentRelations user type.
type CreateCommentRelations struct {
	// This defines the creator of the comment
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment.
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the parent comment resource.
	ParentComment *RelationGeneric `form:"parent-comment,omitempty" json:"parent-comment,omitempty" xml:"parent-comment,omitempty"`
}

// createIdentityDataAttributes user type.
type createIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate validates the createIdentityDataAttributes type instance.
func (ut *createIdentityDataAttributes) Validate() (err error) {
	if ut.UserID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "userID"))
	}
	if ut.Username == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "username"))
	}
	if ut.Email == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "email"))
	}
	if ut.ProviderType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "providerType"))
	}
	return
}

// Publicize creates CreateIdentityDataAttributes from createIdentityDataAttributes
func (ut *createIdentityDataAttributes) Publicize() *CreateIdentityDataAttributes {
	var pub CreateIdentityDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Email != nil {
		pub.Email = *ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = *ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.UserID != nil {
		pub.UserID = *ut.UserID
	}
	if ut.Username != nil {
		pub.Username = *ut.Username
	}
	return &pub
}

// CreateIdentityDataAttributes user type.
type CreateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email string `form:"email" json:"email" xml:"email"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType string `form:"providerType" json:"providerType" xml:"providerType"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID string `form:"userID" json:"userID" xml:"userID"`
	// The username
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate validates the CreateIdentityDataAttributes type instance.
func (ut *CreateIdentityDataAttributes) Validate() (err error) {
	if ut.UserID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "userID"))
	}
	if ut.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "username"))
	}
	if ut.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "email"))
	}
	if ut.ProviderType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "providerType"))
	}
	return
}

// createTrackerQueryAlternatePayload user type.
type createTrackerQueryAlternatePayload struct {
	// Search query
	Query         *string                    `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	Relationships *trackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule *string `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Tracker ID
	TrackerID *uuid.UUID `form:"trackerID,omitempty" json:"trackerID,omitempty" xml:"trackerID,omitempty"`
}

// Validate validates the createTrackerQueryAlternatePayload type instance.
func (ut *createTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "query"))
	}
	if ut.Schedule == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "schedule"))
	}
	if ut.TrackerID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "trackerID"))
	}
	if ut.Query != nil {
		if utf8.RuneCountInString(*ut.Query) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.query`, *ut.Query, utf8.RuneCountInString(*ut.Query), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Schedule != nil {
		if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, *ut.Schedule); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.schedule`, *ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
		}
	}
	if ut.Schedule != nil {
		if utf8.RuneCountInString(*ut.Schedule) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.schedule`, *ut.Schedule, utf8.RuneCountInString(*ut.Schedule), 1, true))
		}
	}
	return
}

// Publicize creates CreateTrackerQueryAlternatePayload from createTrackerQueryAlternatePayload
func (ut *createTrackerQueryAlternatePayload) Publicize() *CreateTrackerQueryAlternatePayload {
	var pub CreateTrackerQueryAlternatePayload
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Schedule != nil {
		pub.Schedule = *ut.Schedule
	}
	if ut.TrackerID != nil {
		pub.TrackerID = *ut.TrackerID
	}
	return &pub
}

// CreateTrackerQueryAlternatePayload user type.
type CreateTrackerQueryAlternatePayload struct {
	// Search query
	Query         string                     `form:"query" json:"query" xml:"query"`
	Relationships *TrackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule string `form:"schedule" json:"schedule" xml:"schedule"`
	// Tracker ID
	TrackerID uuid.UUID `form:"trackerID" json:"trackerID" xml:"trackerID"`
}

// Validate validates the CreateTrackerQueryAlternatePayload type instance.
func (ut *CreateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "query"))
	}
	if ut.Schedule == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "schedule"))
	}

	if utf8.RuneCountInString(ut.Query) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.query`, ut.Query, utf8.RuneCountInString(ut.Query), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, ut.Schedule); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.schedule`, ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
	}
	if utf8.RuneCountInString(ut.Schedule) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.schedule`, ut.Schedule, utf8.RuneCountInString(ut.Schedule), 1, true))
	}
	return
}

// createUserData user type.
type createUserData struct {
	// Attributes of the user identity
	Attributes *createIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createUserData type instance.
func (ut *createUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateUserData from createUserData
func (ut *createUserData) Publicize() *CreateUserData {
	var pub CreateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// CreateUserData user type.
type CreateUserData struct {
	// Attributes of the user identity
	Attributes *CreateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateUserData type instance.
func (ut *CreateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemLinkPayload user type.
type createWorkItemLinkPayload struct {
	Data *workItemLinkData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the createWorkItemLinkPayload type instance.
func (ut *createWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateWorkItemLinkPayload from createWorkItemLinkPayload
func (ut *createWorkItemLinkPayload) Publicize() *CreateWorkItemLinkPayload {
	var pub CreateWorkItemLinkPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// CreateWorkItemLinkPayload user type.
type CreateWorkItemLinkPayload struct {
	Data *WorkItemLinkData `form:"data" json:"data" xml:"data"`
}

// Validate validates the CreateWorkItemLinkPayload type instance.
func (ut *CreateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemLinkTypePayload user type.
type createWorkItemLinkTypePayload struct {
	Data *workItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the createWorkItemLinkTypePayload type instance.
func (ut *createWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateWorkItemLinkTypePayload from createWorkItemLinkTypePayload
func (ut *createWorkItemLinkTypePayload) Publicize() *CreateWorkItemLinkTypePayload {
	var pub CreateWorkItemLinkTypePayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// CreateWorkItemLinkTypePayload user type.
type CreateWorkItemLinkTypePayload struct {
	Data *WorkItemLinkTypeData `form:"data" json:"data" xml:"data"`
}

// Validate validates the CreateWorkItemLinkTypePayload type instance.
func (ut *CreateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemPayload user type.
type createWorkItemPayload struct {
	// The field values, must conform to the type
	Fields map[string]interface{} `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	// ID of the work item type of the newly created work item
	Type *uuid.UUID `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createWorkItemPayload type instance.
func (ut *createWorkItemPayload) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "fields"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	return
}

// Publicize creates CreateWorkItemPayload from createWorkItemPayload
func (ut *createWorkItemPayload) Publicize() *CreateWorkItemPayload {
	var pub CreateWorkItemPayload
	if ut.Fields != nil {
		pub.Fields = ut.Fields
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// CreateWorkItemPayload user type.
type CreateWorkItemPayload struct {
	// The field values, must conform to the type
	Fields map[string]interface{} `form:"fields" json:"fields" xml:"fields"`
	// ID of the work item type of the newly created work item
	Type uuid.UUID `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateWorkItemPayload type instance.
func (ut *CreateWorkItemPayload) Validate() (err error) {

	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "fields"))
	}
	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	return
}

// createWorkspaceData user type.
type createWorkspaceData struct {
	// Attributes of the workspace
	Attributes *createWorkspaceDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
}

// Publicize creates CreateWorkspaceData from createWorkspaceData
func (ut *createWorkspaceData) Publicize() *CreateWorkspaceData {
	var pub CreateWorkspaceData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	return &pub
}

// CreateWorkspaceData user type.
type CreateWorkspaceData struct {
	// Attributes of the workspace
	Attributes *CreateWorkspaceDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
}

// createWorkspaceDataAttributes user type.
type createWorkspaceDataAttributes struct {
	// The workspace branch
	Branch *string `form:"branch,omitempty" json:"branch,omitempty" xml:"branch,omitempty"`
}

// Publicize creates CreateWorkspaceDataAttributes from createWorkspaceDataAttributes
func (ut *createWorkspaceDataAttributes) Publicize() *CreateWorkspaceDataAttributes {
	var pub CreateWorkspaceDataAttributes
	if ut.Branch != nil {
		pub.Branch = ut.Branch
	}
	return &pub
}

// CreateWorkspaceDataAttributes user type.
type CreateWorkspaceDataAttributes struct {
	// The workspace branch
	Branch *string `form:"branch,omitempty" json:"branch,omitempty" xml:"branch,omitempty"`
}

// dataKindUUID user type.
type dataKindUUID struct {
	// UUID of the object
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the dataKindUUID type instance.
func (ut *dataKindUUID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	return
}

// Publicize creates DataKindUUID from dataKindUUID
func (ut *dataKindUUID) Publicize() *DataKindUUID {
	var pub DataKindUUID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// DataKindUUID user type.
type DataKindUUID struct {
	// UUID of the object
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the DataKindUUID type instance.
func (ut *DataKindUUID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	return
}

// JSONAPI store for the data of all endpoints.
type endpoints struct {
	// ID of endpoints (this is a newly generated UUID upon every call)
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// Describes relationship between names and links
	Relationships map[string]interface{} `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the endpoints type instance.
func (ut *endpoints) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Links == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "links"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "relationships"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "endpoints") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"endpoints"}))
		}
	}
	return
}

// Publicize creates Endpoints from endpoints
func (ut *endpoints) Publicize() *Endpoints {
	var pub Endpoints
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of all endpoints.
type Endpoints struct {
	// ID of endpoints (this is a newly generated UUID upon every call)
	ID    uuid.UUID     `form:"id" json:"id" xml:"id"`
	Links *GenericLinks `form:"links" json:"links" xml:"links"`
	// Describes relationship between names and links
	Relationships map[string]interface{} `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string                 `form:"type" json:"type" xml:"type"`
}

// Validate validates the Endpoints type instance.
func (ut *Endpoints) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Links == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "links"))
	}

	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "relationships"))
	}
	if !(ut.Type == "endpoints") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"endpoints"}))
	}
	return
}

// environment object counts
type envStatQuota struct {
	Quota *float64 `form:"quota,omitempty" json:"quota,omitempty" xml:"quota,omitempty"`
	Used  *float64 `form:"used,omitempty" json:"used,omitempty" xml:"used,omitempty"`
}

// Publicize creates EnvStatQuota from envStatQuota
func (ut *envStatQuota) Publicize() *EnvStatQuota {
	var pub EnvStatQuota
	if ut.Quota != nil {
		pub.Quota = ut.Quota
	}
	if ut.Used != nil {
		pub.Used = ut.Used
	}
	return &pub
}

// environment object counts
type EnvStatQuota struct {
	Quota *float64 `form:"quota,omitempty" json:"quota,omitempty" xml:"quota,omitempty"`
	Used  *float64 `form:"used,omitempty" json:"used,omitempty" xml:"used,omitempty"`
}

// resource usage and quotas for an environment
type envStats struct {
	ConfigMaps             *envStatQuota `form:"config_maps,omitempty" json:"config_maps,omitempty" xml:"config_maps,omitempty"`
	Cpucores               *envStatQuota `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	ImageStreams           *envStatQuota `form:"image_streams,omitempty" json:"image_streams,omitempty" xml:"image_streams,omitempty"`
	Memory                 *envStatQuota `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	PersistentVolumeClaims *envStatQuota `form:"persistent_volume_claims,omitempty" json:"persistent_volume_claims,omitempty" xml:"persistent_volume_claims,omitempty"`
	Pods                   *envStatQuota `form:"pods,omitempty" json:"pods,omitempty" xml:"pods,omitempty"`
	ReplicationControllers *envStatQuota `form:"replication_controllers,omitempty" json:"replication_controllers,omitempty" xml:"replication_controllers,omitempty"`
	ResourceQuotas         *envStatQuota `form:"resource_quotas,omitempty" json:"resource_quotas,omitempty" xml:"resource_quotas,omitempty"`
	Secrets                *envStatQuota `form:"secrets,omitempty" json:"secrets,omitempty" xml:"secrets,omitempty"`
	Services               *envStatQuota `form:"services,omitempty" json:"services,omitempty" xml:"services,omitempty"`
}

// Publicize creates EnvStats from envStats
func (ut *envStats) Publicize() *EnvStats {
	var pub EnvStats
	if ut.ConfigMaps != nil {
		pub.ConfigMaps = ut.ConfigMaps.Publicize()
	}
	if ut.Cpucores != nil {
		pub.Cpucores = ut.Cpucores.Publicize()
	}
	if ut.ImageStreams != nil {
		pub.ImageStreams = ut.ImageStreams.Publicize()
	}
	if ut.Memory != nil {
		pub.Memory = ut.Memory.Publicize()
	}
	if ut.PersistentVolumeClaims != nil {
		pub.PersistentVolumeClaims = ut.PersistentVolumeClaims.Publicize()
	}
	if ut.Pods != nil {
		pub.Pods = ut.Pods.Publicize()
	}
	if ut.ReplicationControllers != nil {
		pub.ReplicationControllers = ut.ReplicationControllers.Publicize()
	}
	if ut.ResourceQuotas != nil {
		pub.ResourceQuotas = ut.ResourceQuotas.Publicize()
	}
	if ut.Secrets != nil {
		pub.Secrets = ut.Secrets.Publicize()
	}
	if ut.Services != nil {
		pub.Services = ut.Services.Publicize()
	}
	return &pub
}

// resource usage and quotas for an environment
type EnvStats struct {
	ConfigMaps             *EnvStatQuota `form:"config_maps,omitempty" json:"config_maps,omitempty" xml:"config_maps,omitempty"`
	Cpucores               *EnvStatQuota `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	ImageStreams           *EnvStatQuota `form:"image_streams,omitempty" json:"image_streams,omitempty" xml:"image_streams,omitempty"`
	Memory                 *EnvStatQuota `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	PersistentVolumeClaims *EnvStatQuota `form:"persistent_volume_claims,omitempty" json:"persistent_volume_claims,omitempty" xml:"persistent_volume_claims,omitempty"`
	Pods                   *EnvStatQuota `form:"pods,omitempty" json:"pods,omitempty" xml:"pods,omitempty"`
	ReplicationControllers *EnvStatQuota `form:"replication_controllers,omitempty" json:"replication_controllers,omitempty" xml:"replication_controllers,omitempty"`
	ResourceQuotas         *EnvStatQuota `form:"resource_quotas,omitempty" json:"resource_quotas,omitempty" xml:"resource_quotas,omitempty"`
	Secrets                *EnvStatQuota `form:"secrets,omitempty" json:"secrets,omitempty" xml:"secrets,omitempty"`
	Services               *EnvStatQuota `form:"services,omitempty" json:"services,omitempty" xml:"services,omitempty"`
}

// JSONAPI store for the data of a event.  See also http://jsonapi.org/format/#document-resource-object
type event struct {
	Attributes *eventAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of event. NOTE: this is not the ID of the work item revision but a random ID that is unique for this event.
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *eventRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string         `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the event type instance.
func (ut *event) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "relationships"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "events") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"events"}))
		}
	}
	return
}

// Publicize creates Event from event
func (ut *event) Publicize() *Event {
	var pub Event
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a event.  See also http://jsonapi.org/format/#document-resource-object
type Event struct {
	Attributes *EventAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of event. NOTE: this is not the ID of the work item revision but a random ID that is unique for this event.
	ID            uuid.UUID       `form:"id" json:"id" xml:"id"`
	Links         *GenericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *EventRelations `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string          `form:"type" json:"type" xml:"type"`
}

// Validate validates the Event type instance.
func (ut *Event) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "relationships"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}

	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "events") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"events"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a event. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type eventAttributes struct {
	// The name of the event occured
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The user who performed the assignment (or unassignment). Only for 'assigned' and 'unassigned' events..
	NewValue *interface{} `form:"newValue,omitempty" json:"newValue,omitempty" xml:"newValue,omitempty"`
	// The user who was assigned to (or unassigned from). Only for 'assigned' and 'unassigned' events.
	OldValue *interface{} `form:"oldValue,omitempty" json:"oldValue,omitempty" xml:"oldValue,omitempty"`
	// ID of the revision
	RevisionID *uuid.UUID `form:"revisionId,omitempty" json:"revisionId,omitempty" xml:"revisionId,omitempty"`
	// When the event occurred
	Timestamp *time.Time `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the eventAttributes type instance.
func (ut *eventAttributes) Validate() (err error) {
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "timestamp"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.RevisionID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "revisionId"))
	}
	return
}

// Publicize creates EventAttributes from eventAttributes
func (ut *eventAttributes) Publicize() *EventAttributes {
	var pub EventAttributes
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.NewValue != nil {
		pub.NewValue = ut.NewValue
	}
	if ut.OldValue != nil {
		pub.OldValue = ut.OldValue
	}
	if ut.RevisionID != nil {
		pub.RevisionID = *ut.RevisionID
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a event. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type EventAttributes struct {
	// The name of the event occured
	Name string `form:"name" json:"name" xml:"name"`
	// The user who performed the assignment (or unassignment). Only for 'assigned' and 'unassigned' events..
	NewValue *interface{} `form:"newValue,omitempty" json:"newValue,omitempty" xml:"newValue,omitempty"`
	// The user who was assigned to (or unassigned from). Only for 'assigned' and 'unassigned' events.
	OldValue *interface{} `form:"oldValue,omitempty" json:"oldValue,omitempty" xml:"oldValue,omitempty"`
	// ID of the revision
	RevisionID uuid.UUID `form:"revisionId" json:"revisionId" xml:"revisionId"`
	// When the event occurred
	Timestamp time.Time `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the EventAttributes type instance.
func (ut *EventAttributes) Validate() (err error) {

	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}

	return
}

// eventRelations user type.
type eventRelations struct {
	// This defines the modifier of the event
	Modifier *relationGeneric     `form:"modifier,omitempty" json:"modifier,omitempty" xml:"modifier,omitempty"`
	NewValue *relationGenericList `form:"newValue,omitempty" json:"newValue,omitempty" xml:"newValue,omitempty"`
	OldValue *relationGenericList `form:"oldValue,omitempty" json:"oldValue,omitempty" xml:"oldValue,omitempty"`
	// The type of the work item at the event's point in time
	WorkItemType *relationGeneric `form:"workItemType,omitempty" json:"workItemType,omitempty" xml:"workItemType,omitempty"`
}

// Validate validates the eventRelations type instance.
func (ut *eventRelations) Validate() (err error) {
	if ut.WorkItemType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "workItemType"))
	}
	if ut.Modifier == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "modifier"))
	}
	return
}

// Publicize creates EventRelations from eventRelations
func (ut *eventRelations) Publicize() *EventRelations {
	var pub EventRelations
	if ut.Modifier != nil {
		pub.Modifier = ut.Modifier.Publicize()
	}
	if ut.NewValue != nil {
		pub.NewValue = ut.NewValue.Publicize()
	}
	if ut.OldValue != nil {
		pub.OldValue = ut.OldValue.Publicize()
	}
	if ut.WorkItemType != nil {
		pub.WorkItemType = ut.WorkItemType.Publicize()
	}
	return &pub
}

// EventRelations user type.
type EventRelations struct {
	// This defines the modifier of the event
	Modifier *RelationGeneric     `form:"modifier" json:"modifier" xml:"modifier"`
	NewValue *RelationGenericList `form:"newValue,omitempty" json:"newValue,omitempty" xml:"newValue,omitempty"`
	OldValue *RelationGenericList `form:"oldValue,omitempty" json:"oldValue,omitempty" xml:"oldValue,omitempty"`
	// The type of the work item at the event's point in time
	WorkItemType *RelationGeneric `form:"workItemType" json:"workItemType" xml:"workItemType"`
}

// Validate validates the EventRelations type instance.
func (ut *EventRelations) Validate() (err error) {
	if ut.WorkItemType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "workItemType"))
	}
	if ut.Modifier == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "modifier"))
	}
	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// genericLinksForDeployment user type.
type genericLinksForDeployment struct {
	Application *string `form:"application,omitempty" json:"application,omitempty" xml:"application,omitempty"`
	Console     *string `form:"console,omitempty" json:"console,omitempty" xml:"console,omitempty"`
	Logs        *string `form:"logs,omitempty" json:"logs,omitempty" xml:"logs,omitempty"`
}

// Publicize creates GenericLinksForDeployment from genericLinksForDeployment
func (ut *genericLinksForDeployment) Publicize() *GenericLinksForDeployment {
	var pub GenericLinksForDeployment
	if ut.Application != nil {
		pub.Application = ut.Application
	}
	if ut.Console != nil {
		pub.Console = ut.Console
	}
	if ut.Logs != nil {
		pub.Logs = ut.Logs
	}
	return &pub
}

// GenericLinksForDeployment user type.
type GenericLinksForDeployment struct {
	Application *string `form:"application,omitempty" json:"application,omitempty" xml:"application,omitempty"`
	Console     *string `form:"console,omitempty" json:"console,omitempty" xml:"console,omitempty"`
	Logs        *string `form:"logs,omitempty" json:"logs,omitempty" xml:"logs,omitempty"`
}

// genericLinksForSpace user type.
type genericLinksForSpace struct {
	// URL to the backlog work items
	Backlog *backlogGenericLink `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// URL to the list of the space collaborators
	Collaborators *string `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// URL to the list of available filters
	Filters *string                `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
	// URL to the list all work item boards
	Workitemboards *string `form:"workitemboards,omitempty" json:"workitemboards,omitempty" xml:"workitemboards,omitempty"`
	// URL to list all WILTs for this space
	Workitemlinktypes *string `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// URL to the list all work item type groups
	Workitemtypegroups *string `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// URL to list all WITs for this space
	Workitemtypes *string `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the genericLinksForSpace type instance.
func (ut *genericLinksForSpace) Validate() (err error) {
	if ut.Backlog != nil {
		if err2 := ut.Backlog.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates GenericLinksForSpace from genericLinksForSpace
func (ut *genericLinksForSpace) Publicize() *GenericLinksForSpace {
	var pub GenericLinksForSpace
	if ut.Backlog != nil {
		pub.Backlog = ut.Backlog.Publicize()
	}
	if ut.Collaborators != nil {
		pub.Collaborators = ut.Collaborators
	}
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	if ut.Workitemboards != nil {
		pub.Workitemboards = ut.Workitemboards
	}
	if ut.Workitemlinktypes != nil {
		pub.Workitemlinktypes = ut.Workitemlinktypes
	}
	if ut.Workitemtypegroups != nil {
		pub.Workitemtypegroups = ut.Workitemtypegroups
	}
	if ut.Workitemtypes != nil {
		pub.Workitemtypes = ut.Workitemtypes
	}
	return &pub
}

// GenericLinksForSpace user type.
type GenericLinksForSpace struct {
	// URL to the backlog work items
	Backlog *BacklogGenericLink `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// URL to the list of the space collaborators
	Collaborators *string `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// URL to the list of available filters
	Filters *string                `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
	// URL to the list all work item boards
	Workitemboards *string `form:"workitemboards,omitempty" json:"workitemboards,omitempty" xml:"workitemboards,omitempty"`
	// URL to list all WILTs for this space
	Workitemlinktypes *string `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// URL to the list all work item type groups
	Workitemtypegroups *string `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// URL to list all WITs for this space
	Workitemtypes *string `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// genericLinksForWorkItem user type.
type genericLinksForWorkItem struct {
	// URL to generate Che-editor's link based on values of codebase field
	EditCodebase *string                `form:"editCodebase,omitempty" json:"editCodebase,omitempty" xml:"editCodebase,omitempty"`
	Meta         map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related      *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self         *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinksForWorkItem from genericLinksForWorkItem
func (ut *genericLinksForWorkItem) Publicize() *GenericLinksForWorkItem {
	var pub GenericLinksForWorkItem
	if ut.EditCodebase != nil {
		pub.EditCodebase = ut.EditCodebase
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinksForWorkItem user type.
type GenericLinksForWorkItem struct {
	// URL to generate Che-editor's link based on values of codebase field
	EditCodebase *string                `form:"editCodebase,omitempty" json:"editCodebase,omitempty" xml:"editCodebase,omitempty"`
	Meta         map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related      *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self         *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// identityRelationData user type.
type identityRelationData struct {
	// unique id for the user identity
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the identityRelationData type instance.
func (ut *identityRelationData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "identities") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"identities"}))
		}
	}
	return
}

// Publicize creates IdentityRelationData from identityRelationData
func (ut *identityRelationData) Publicize() *IdentityRelationData {
	var pub IdentityRelationData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// IdentityRelationData user type.
type IdentityRelationData struct {
	// unique id for the user identity
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the IdentityRelationData type instance.
func (ut *IdentityRelationData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if !(ut.Type == "identities") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"identities"}))
	}
	return
}

// JSONAPI store for the data of a iteration.  See also http://jsonapi.org/format/#document-resource-object
type iteration struct {
	Attributes *iterationAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of iteration.
	//  This is MANDATORY on update of resource.
	ID            *uuid.UUID          `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks       `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *iterationRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string             `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the iteration type instance.
func (ut *iteration) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "iterations") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"iterations"}))
		}
	}
	return
}

// Publicize creates Iteration from iteration
func (ut *iteration) Publicize() *Iteration {
	var pub Iteration
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a iteration.  See also http://jsonapi.org/format/#document-resource-object
type Iteration struct {
	Attributes *IterationAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of iteration.
	//  This is MANDATORY on update of resource.
	ID            *uuid.UUID          `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks       `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *IterationRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string              `form:"type" json:"type" xml:"type"`
}

// Validate validates the Iteration type instance.
func (ut *Iteration) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "iterations") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"iterations"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a iteration. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type iterationAttributes struct {
	// Active status of iteration calculated using user_active, startAt and endAt
	ActiveStatus *bool `form:"active_status,omitempty" json:"active_status,omitempty" xml:"active_status,omitempty"`
	// When the iteration was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the iteration
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// When the iteration ends
	EndAt *time.Time `form:"endAt,omitempty" json:"endAt,omitempty" xml:"endAt,omitempty"`
	// The iteration name.
	//  This is MANDATORY on creation of resource.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Human-friendly number of the iteration that is unique inside the iteration's space
	Number *int `form:"number,omitempty" json:"number,omitempty" xml:"number,omitempty"`
	// Path string separataed by / having UUIDs of all parent iterations
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path string separataed by / having names of all parent iterations
	ResolvedParentPath *string `form:"resolved_parent_path,omitempty" json:"resolved_parent_path,omitempty" xml:"resolved_parent_path,omitempty"`
	// When the iteration starts
	StartAt *time.Time `form:"startAt,omitempty" json:"startAt,omitempty" xml:"startAt,omitempty"`
	// State of an iteration
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// When the iteration was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Active flag set by user
	UserActive *bool `form:"user_active,omitempty" json:"user_active,omitempty" xml:"user_active,omitempty"`
}

// Validate validates the iterationAttributes type instance.
func (ut *iterationAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	if ut.State != nil {
		if !(*ut.State == "new" || *ut.State == "start" || *ut.State == "close") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.state`, *ut.State, []interface{}{"new", "start", "close"}))
		}
	}
	return
}

// Publicize creates IterationAttributes from iterationAttributes
func (ut *iterationAttributes) Publicize() *IterationAttributes {
	var pub IterationAttributes
	if ut.ActiveStatus != nil {
		pub.ActiveStatus = ut.ActiveStatus
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.EndAt != nil {
		pub.EndAt = ut.EndAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Number != nil {
		pub.Number = ut.Number
	}
	if ut.ParentPath != nil {
		pub.ParentPath = ut.ParentPath
	}
	if ut.ResolvedParentPath != nil {
		pub.ResolvedParentPath = ut.ResolvedParentPath
	}
	if ut.StartAt != nil {
		pub.StartAt = ut.StartAt
	}
	if ut.State != nil {
		pub.State = ut.State
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.UserActive != nil {
		pub.UserActive = ut.UserActive
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a iteration. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type IterationAttributes struct {
	// Active status of iteration calculated using user_active, startAt and endAt
	ActiveStatus *bool `form:"active_status,omitempty" json:"active_status,omitempty" xml:"active_status,omitempty"`
	// When the iteration was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the iteration
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// When the iteration ends
	EndAt *time.Time `form:"endAt,omitempty" json:"endAt,omitempty" xml:"endAt,omitempty"`
	// The iteration name.
	//  This is MANDATORY on creation of resource.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Human-friendly number of the iteration that is unique inside the iteration's space
	Number *int `form:"number,omitempty" json:"number,omitempty" xml:"number,omitempty"`
	// Path string separataed by / having UUIDs of all parent iterations
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path string separataed by / having names of all parent iterations
	ResolvedParentPath *string `form:"resolved_parent_path,omitempty" json:"resolved_parent_path,omitempty" xml:"resolved_parent_path,omitempty"`
	// When the iteration starts
	StartAt *time.Time `form:"startAt,omitempty" json:"startAt,omitempty" xml:"startAt,omitempty"`
	// State of an iteration
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// When the iteration was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Active flag set by user
	UserActive *bool `form:"user_active,omitempty" json:"user_active,omitempty" xml:"user_active,omitempty"`
}

// Validate validates the IterationAttributes type instance.
func (ut *IterationAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	if ut.State != nil {
		if !(*ut.State == "new" || *ut.State == "start" || *ut.State == "close") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.state`, *ut.State, []interface{}{"new", "start", "close"}))
		}
	}
	return
}

// iterationRelations user type.
type iterationRelations struct {
	// This defines the parent iteration
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the iteration
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Publicize creates IterationRelations from iterationRelations
func (ut *iterationRelations) Publicize() *IterationRelations {
	var pub IterationRelations
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	return &pub
}

// IterationRelations user type.
type IterationRelations struct {
	// This defines the parent iteration
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the iteration
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// JSONAPI store for the data of a Label. See also http://jsonapi.org/format/#document-resource-object
type label struct {
	Attributes *labelAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of label
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *labelRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string         `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the label type instance.
func (ut *label) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "labels") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"labels"}))
		}
	}
	return
}

// Publicize creates Label from label
func (ut *label) Publicize() *Label {
	var pub Label
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Label. See also http://jsonapi.org/format/#document-resource-object
type Label struct {
	Attributes *LabelAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of label
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *LabelRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string          `form:"type" json:"type" xml:"type"`
}

// Validate validates the Label type instance.
func (ut *Label) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "labels") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"labels"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Label. See also http://jsonapi.org/format/#document-resource-object-attributes
type labelAttributes struct {
	// Background color in hex code format. See also http://www.color-hex.com
	BackgroundColor *string `form:"background-color,omitempty" json:"background-color,omitempty" xml:"background-color,omitempty"`
	// Border color in hex code format. See also http://www.color-hex.com
	BorderColor *string `form:"border-color,omitempty" json:"border-color,omitempty" xml:"border-color,omitempty"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Label name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Text color in hex code format. See also http://www.color-hex.com
	TextColor *string `form:"text-color,omitempty" json:"text-color,omitempty" xml:"text-color,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the labelAttributes type instance.
func (ut *labelAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Publicize creates LabelAttributes from labelAttributes
func (ut *labelAttributes) Publicize() *LabelAttributes {
	var pub LabelAttributes
	if ut.BackgroundColor != nil {
		pub.BackgroundColor = ut.BackgroundColor
	}
	if ut.BorderColor != nil {
		pub.BorderColor = ut.BorderColor
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.TextColor != nil {
		pub.TextColor = ut.TextColor
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Label. See also http://jsonapi.org/format/#document-resource-object-attributes
type LabelAttributes struct {
	// Background color in hex code format. See also http://www.color-hex.com
	BackgroundColor *string `form:"background-color,omitempty" json:"background-color,omitempty" xml:"background-color,omitempty"`
	// Border color in hex code format. See also http://www.color-hex.com
	BorderColor *string `form:"border-color,omitempty" json:"border-color,omitempty" xml:"border-color,omitempty"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Label name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Text color in hex code format. See also http://www.color-hex.com
	TextColor *string `form:"text-color,omitempty" json:"text-color,omitempty" xml:"text-color,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the LabelAttributes type instance.
func (ut *LabelAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// labelRelations user type.
type labelRelations struct {
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Publicize creates LabelRelations from labelRelations
func (ut *labelRelations) Publicize() *LabelRelations {
	var pub LabelRelations
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// LabelRelations user type.
type LabelRelations struct {
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// markupRenderingData user type.
type markupRenderingData struct {
	Attributes *markupRenderingDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// an ID to conform to the JSON-API spec, even though it is meaningless in the case of the rendering endpoint. Can be null
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the markupRenderingData type instance.
func (ut *markupRenderingData) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "rendering") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"rendering"}))
		}
	}
	return
}

// Publicize creates MarkupRenderingData from markupRenderingData
func (ut *markupRenderingData) Publicize() *MarkupRenderingData {
	var pub MarkupRenderingData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// MarkupRenderingData user type.
type MarkupRenderingData struct {
	Attributes *MarkupRenderingDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// an ID to conform to the JSON-API spec, even though it is meaningless in the case of the rendering endpoint. Can be null
	ID   string `form:"id" json:"id" xml:"id"`
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the MarkupRenderingData type instance.
func (ut *MarkupRenderingData) Validate() (err error) {
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "rendering") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"rendering"}))
	}
	return
}

// markupRenderingDataAttributes user type.
type markupRenderingDataAttributes struct {
	// The rendered content
	RenderedContent *string `form:"renderedContent,omitempty" json:"renderedContent,omitempty" xml:"renderedContent,omitempty"`
}

// Validate validates the markupRenderingDataAttributes type instance.
func (ut *markupRenderingDataAttributes) Validate() (err error) {
	if ut.RenderedContent == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "renderedContent"))
	}
	return
}

// Publicize creates MarkupRenderingDataAttributes from markupRenderingDataAttributes
func (ut *markupRenderingDataAttributes) Publicize() *MarkupRenderingDataAttributes {
	var pub MarkupRenderingDataAttributes
	if ut.RenderedContent != nil {
		pub.RenderedContent = *ut.RenderedContent
	}
	return &pub
}

// MarkupRenderingDataAttributes user type.
type MarkupRenderingDataAttributes struct {
	// The rendered content
	RenderedContent string `form:"renderedContent" json:"renderedContent" xml:"renderedContent"`
}

// Validate validates the MarkupRenderingDataAttributes type instance.
func (ut *MarkupRenderingDataAttributes) Validate() (err error) {
	if ut.RenderedContent == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "renderedContent"))
	}
	return
}

// A MarkupRenderingPayload describes the values that a render request can hold.
type markupRenderingPayload struct {
	Data *markupRenderingPayloadData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the markupRenderingPayload type instance.
func (ut *markupRenderingPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates MarkupRenderingPayload from markupRenderingPayload
func (ut *markupRenderingPayload) Publicize() *MarkupRenderingPayload {
	var pub MarkupRenderingPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// A MarkupRenderingPayload describes the values that a render request can hold.
type MarkupRenderingPayload struct {
	Data *MarkupRenderingPayloadData `form:"data" json:"data" xml:"data"`
}

// Validate validates the MarkupRenderingPayload type instance.
func (ut *MarkupRenderingPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// markupRenderingPayloadData user type.
type markupRenderingPayloadData struct {
	Attributes *markupRenderingPayloadDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Type       *string                               `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the markupRenderingPayloadData type instance.
func (ut *markupRenderingPayloadData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "rendering") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"rendering"}))
		}
	}
	return
}

// Publicize creates MarkupRenderingPayloadData from markupRenderingPayloadData
func (ut *markupRenderingPayloadData) Publicize() *MarkupRenderingPayloadData {
	var pub MarkupRenderingPayloadData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// MarkupRenderingPayloadData user type.
type MarkupRenderingPayloadData struct {
	Attributes *MarkupRenderingPayloadDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Type       string                                `form:"type" json:"type" xml:"type"`
}

// Validate validates the MarkupRenderingPayloadData type instance.
func (ut *MarkupRenderingPayloadData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "rendering") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"rendering"}))
	}
	return
}

// markupRenderingPayloadDataAttributes user type.
type markupRenderingPayloadDataAttributes struct {
	// The content to render
	Content *string `form:"content,omitempty" json:"content,omitempty" xml:"content,omitempty"`
	// The markup language associated with the content to render
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the markupRenderingPayloadDataAttributes type instance.
func (ut *markupRenderingPayloadDataAttributes) Validate() (err error) {
	if ut.Content == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "content"))
	}
	if ut.Markup == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "markup"))
	}
	return
}

// Publicize creates MarkupRenderingPayloadDataAttributes from markupRenderingPayloadDataAttributes
func (ut *markupRenderingPayloadDataAttributes) Publicize() *MarkupRenderingPayloadDataAttributes {
	var pub MarkupRenderingPayloadDataAttributes
	if ut.Content != nil {
		pub.Content = *ut.Content
	}
	if ut.Markup != nil {
		pub.Markup = *ut.Markup
	}
	return &pub
}

// MarkupRenderingPayloadDataAttributes user type.
type MarkupRenderingPayloadDataAttributes struct {
	// The content to render
	Content string `form:"content" json:"content" xml:"content"`
	// The markup language associated with the content to render
	Markup string `form:"markup" json:"markup" xml:"markup"`
}

// Validate validates the MarkupRenderingPayloadDataAttributes type instance.
func (ut *MarkupRenderingPayloadDataAttributes) Validate() (err error) {
	if ut.Content == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "content"))
	}
	if ut.Markup == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "markup"))
	}
	return
}

// JSONAPI store for all the "attributes" of a Tenant namespace. See also see http://jsonapi.org/format/#document-resource-object-attributes
type namespaceAttributes struct {
	// The cluster app domain
	ClusterAppDomain *string `form:"cluster-app-domain,omitempty" json:"cluster-app-domain,omitempty" xml:"cluster-app-domain,omitempty"`
	// Whether cluster hosting this namespace exhausted it's capacity
	ClusterCapacityExhausted *bool `form:"cluster-capacity-exhausted,omitempty" json:"cluster-capacity-exhausted,omitempty" xml:"cluster-capacity-exhausted,omitempty"`
	// The cluster console url
	ClusterConsoleURL *string `form:"cluster-console-url,omitempty" json:"cluster-console-url,omitempty" xml:"cluster-console-url,omitempty"`
	// The cluster logging url
	ClusterLoggingURL *string `form:"cluster-logging-url,omitempty" json:"cluster-logging-url,omitempty" xml:"cluster-logging-url,omitempty"`
	// The cluster metrics url
	ClusterMetricsURL *string `form:"cluster-metrics-url,omitempty" json:"cluster-metrics-url,omitempty" xml:"cluster-metrics-url,omitempty"`
	// The cluster url
	ClusterURL *string `form:"cluster-url,omitempty" json:"cluster-url,omitempty" xml:"cluster-url,omitempty"`
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The namespace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The namespaces state
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The tenant namespaces
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// When the tenant was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The namespaces version
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the namespaceAttributes type instance.
func (ut *namespaceAttributes) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "che" || *ut.Type == "jenkins" || *ut.Type == "stage" || *ut.Type == "test" || *ut.Type == "run") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"che", "jenkins", "stage", "test", "run"}))
		}
	}
	return
}

// Publicize creates NamespaceAttributes from namespaceAttributes
func (ut *namespaceAttributes) Publicize() *NamespaceAttributes {
	var pub NamespaceAttributes
	if ut.ClusterAppDomain != nil {
		pub.ClusterAppDomain = ut.ClusterAppDomain
	}
	if ut.ClusterCapacityExhausted != nil {
		pub.ClusterCapacityExhausted = ut.ClusterCapacityExhausted
	}
	if ut.ClusterConsoleURL != nil {
		pub.ClusterConsoleURL = ut.ClusterConsoleURL
	}
	if ut.ClusterLoggingURL != nil {
		pub.ClusterLoggingURL = ut.ClusterLoggingURL
	}
	if ut.ClusterMetricsURL != nil {
		pub.ClusterMetricsURL = ut.ClusterMetricsURL
	}
	if ut.ClusterURL != nil {
		pub.ClusterURL = ut.ClusterURL
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.State != nil {
		pub.State = ut.State
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Tenant namespace. See also see http://jsonapi.org/format/#document-resource-object-attributes
type NamespaceAttributes struct {
	// The cluster app domain
	ClusterAppDomain *string `form:"cluster-app-domain,omitempty" json:"cluster-app-domain,omitempty" xml:"cluster-app-domain,omitempty"`
	// Whether cluster hosting this namespace exhausted it's capacity
	ClusterCapacityExhausted *bool `form:"cluster-capacity-exhausted,omitempty" json:"cluster-capacity-exhausted,omitempty" xml:"cluster-capacity-exhausted,omitempty"`
	// The cluster console url
	ClusterConsoleURL *string `form:"cluster-console-url,omitempty" json:"cluster-console-url,omitempty" xml:"cluster-console-url,omitempty"`
	// The cluster logging url
	ClusterLoggingURL *string `form:"cluster-logging-url,omitempty" json:"cluster-logging-url,omitempty" xml:"cluster-logging-url,omitempty"`
	// The cluster metrics url
	ClusterMetricsURL *string `form:"cluster-metrics-url,omitempty" json:"cluster-metrics-url,omitempty" xml:"cluster-metrics-url,omitempty"`
	// The cluster url
	ClusterURL *string `form:"cluster-url,omitempty" json:"cluster-url,omitempty" xml:"cluster-url,omitempty"`
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The namespace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The namespaces state
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The tenant namespaces
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// When the tenant was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The namespaces version
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the NamespaceAttributes type instance.
func (ut *NamespaceAttributes) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "che" || *ut.Type == "jenkins" || *ut.Type == "stage" || *ut.Type == "test" || *ut.Type == "run") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, *ut.Type, []interface{}{"che", "jenkins", "stage", "test", "run"}))
		}
	}
	return
}

// resource quotas for pods of a deployment
type podsQuota struct {
	Cpucores *float64 `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	Memory   *float64 `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
}

// Publicize creates PodsQuota from podsQuota
func (ut *podsQuota) Publicize() *PodsQuota {
	var pub PodsQuota
	if ut.Cpucores != nil {
		pub.Cpucores = ut.Cpucores
	}
	if ut.Memory != nil {
		pub.Memory = ut.Memory
	}
	return &pub
}

// resource quotas for pods of a deployment
type PodsQuota struct {
	Cpucores *float64 `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	Memory   *float64 `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
}

// JSONAPI store for the data of a Query. See also http://jsonapi.org/format/#document-resource-object
type query struct {
	Attributes *queryAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of query
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *queryRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string         `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the query type instance.
func (ut *query) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "queries") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"queries"}))
		}
	}
	return
}

// Publicize creates Query from query
func (ut *query) Publicize() *Query {
	var pub Query
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Query. See also http://jsonapi.org/format/#document-resource-object
type Query struct {
	Attributes *QueryAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of query
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *QueryRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string          `form:"type" json:"type" xml:"type"`
}

// Validate validates the Query type instance.
func (ut *Query) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "queries") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"queries"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Query. See also http://jsonapi.org/format/#document-resource-object-attributes
type queryAttributes struct {
	// When the query was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Query fields.
	//  This is MANDATORY on creation of resource.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	// The query title.
	//  This is MANDATORY on creation of resource.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// When the query was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the queryAttributes type instance.
func (ut *queryAttributes) Validate() (err error) {
	if ut.Title == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "title"))
	}
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "fields"))
	}
	if ut.Title != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Title); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.title`, *ut.Title, `^[^_|-].*`))
		}
	}
	if ut.Title != nil {
		if utf8.RuneCountInString(*ut.Title) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.title`, *ut.Title, utf8.RuneCountInString(*ut.Title), 1, true))
		}
	}
	if ut.Title != nil {
		if utf8.RuneCountInString(*ut.Title) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.title`, *ut.Title, utf8.RuneCountInString(*ut.Title), 63, false))
		}
	}
	return
}

// Publicize creates QueryAttributes from queryAttributes
func (ut *queryAttributes) Publicize() *QueryAttributes {
	var pub QueryAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Fields != nil {
		pub.Fields = *ut.Fields
	}
	if ut.Title != nil {
		pub.Title = *ut.Title
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Query. See also http://jsonapi.org/format/#document-resource-object-attributes
type QueryAttributes struct {
	// When the query was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Query fields.
	//  This is MANDATORY on creation of resource.
	Fields string `form:"fields" json:"fields" xml:"fields"`
	// The query title.
	//  This is MANDATORY on creation of resource.
	Title string `form:"title" json:"title" xml:"title"`
	// When the query was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the QueryAttributes type instance.
func (ut *QueryAttributes) Validate() (err error) {
	if ut.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "title"))
	}
	if ut.Fields == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "fields"))
	}
	if ok := goa.ValidatePattern(`^[^_|-].*`, ut.Title); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.title`, ut.Title, `^[^_|-].*`))
	}
	if utf8.RuneCountInString(ut.Title) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.title`, ut.Title, utf8.RuneCountInString(ut.Title), 1, true))
	}
	if utf8.RuneCountInString(ut.Title) > 63 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.title`, ut.Title, utf8.RuneCountInString(ut.Title), 63, false))
	}
	return
}

// queryRelations user type.
type queryRelations struct {
	// This defines the creator of the query
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the space in which query is saved
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Publicize creates QueryRelations from queryRelations
func (ut *queryRelations) Publicize() *QueryRelations {
	var pub QueryRelations
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// QueryRelations user type.
type QueryRelations struct {
	// This defines the creator of the query
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the space in which query is saved
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// relationBaseType user type.
type relationBaseType struct {
	Data  *baseTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationBaseType type instance.
func (ut *relationBaseType) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationBaseType from relationBaseType
func (ut *relationBaseType) Publicize() *RelationBaseType {
	var pub RelationBaseType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationBaseType user type.
type RelationBaseType struct {
	Data  *BaseTypeData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationBaseType type instance.
func (ut *RelationBaseType) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationKindUUID user type.
type relationKindUUID struct {
	Data  *dataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationKindUUID type instance.
func (ut *relationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationKindUUID from relationKindUUID
func (ut *relationKindUUID) Publicize() *RelationKindUUID {
	var pub RelationKindUUID
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationKindUUID user type.
type RelationKindUUID struct {
	Data  *DataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationKindUUID type instance.
func (ut *RelationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationSpaces user type.
type relationSpaces struct {
	Data  *relationSpacesData    `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationSpaces type instance.
func (ut *relationSpaces) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationSpaces from relationSpaces
func (ut *relationSpaces) Publicize() *RelationSpaces {
	var pub RelationSpaces
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationSpaces user type.
type RelationSpaces struct {
	Data  *RelationSpacesData    `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationSpaces type instance.
func (ut *RelationSpaces) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationSpacesData user type.
type relationSpacesData struct {
	// UUID for the space
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationSpacesData type instance.
func (ut *relationSpacesData) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// Publicize creates RelationSpacesData from relationSpacesData
func (ut *relationSpacesData) Publicize() *RelationSpacesData {
	var pub RelationSpacesData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// RelationSpacesData user type.
type RelationSpacesData struct {
	// UUID for the space
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the RelationSpacesData type instance.
func (ut *RelationSpacesData) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// relationWorkItem user type.
type relationWorkItem struct {
	Data  *relationWorkItemData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationWorkItem type instance.
func (ut *relationWorkItem) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItem from relationWorkItem
func (ut *relationWorkItem) Publicize() *RelationWorkItem {
	var pub RelationWorkItem
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationWorkItem user type.
type RelationWorkItem struct {
	Data  *RelationWorkItemData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationWorkItem type instance.
func (ut *RelationWorkItem) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemData user type.
type relationWorkItemData struct {
	// ID (UUID) of the work item
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemData type instance.
func (ut *relationWorkItemData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitems") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitems"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemData from relationWorkItemData
func (ut *relationWorkItemData) Publicize() *RelationWorkItemData {
	var pub RelationWorkItemData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemData user type.
type RelationWorkItemData struct {
	// ID (UUID) of the work item
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemData type instance.
func (ut *RelationWorkItemData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if !(ut.Type == "workitems") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitems"}))
	}
	return
}

// relationWorkItemLinkType user type.
type relationWorkItemLinkType struct {
	Data  *relationWorkItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationWorkItemLinkType type instance.
func (ut *relationWorkItemLinkType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkType from relationWorkItemLinkType
func (ut *relationWorkItemLinkType) Publicize() *RelationWorkItemLinkType {
	var pub RelationWorkItemLinkType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationWorkItemLinkType user type.
type RelationWorkItemLinkType struct {
	Data  *RelationWorkItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationWorkItemLinkType type instance.
func (ut *RelationWorkItemLinkType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemLinkTypeData user type.
type relationWorkItemLinkTypeData struct {
	// ID of work item link type
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related source
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemLinkTypeData type instance.
func (ut *relationWorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinktypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemlinktypes"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkTypeData from relationWorkItemLinkTypeData
func (ut *relationWorkItemLinkTypeData) Publicize() *RelationWorkItemLinkTypeData {
	var pub RelationWorkItemLinkTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemLinkTypeData user type.
type RelationWorkItemLinkTypeData struct {
	// ID of work item link type
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related source
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemLinkTypeData type instance.
func (ut *RelationWorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if !(ut.Type == "workitemlinktypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemlinktypes"}))
	}
	return
}

// relationWorkItemType user type.
type relationWorkItemType struct {
	Data  *relationWorkItemTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks             `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationWorkItemType type instance.
func (ut *relationWorkItemType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItemType from relationWorkItemType
func (ut *relationWorkItemType) Publicize() *RelationWorkItemType {
	var pub RelationWorkItemType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationWorkItemType user type.
type RelationWorkItemType struct {
	Data  *RelationWorkItemTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks             `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationWorkItemType type instance.
func (ut *RelationWorkItemType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemTypeData user type.
type relationWorkItemTypeData struct {
	// ID of a work item type
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemTypeData type instance.
func (ut *relationWorkItemTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemTypeData from relationWorkItemTypeData
func (ut *relationWorkItemTypeData) Publicize() *RelationWorkItemTypeData {
	var pub RelationWorkItemTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemTypeData user type.
type RelationWorkItemTypeData struct {
	// ID of a work item type
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemTypeData type instance.
func (ut *RelationWorkItemTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// a description of an application
type simpleApp struct {
	Attributes *simpleAppAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the application (same as 'name')
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the simpleApp type instance.
func (ut *simpleApp) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "application") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"application"}))
		}
	}
	return
}

// Publicize creates SimpleApp from simpleApp
func (ut *simpleApp) Publicize() *SimpleApp {
	var pub SimpleApp
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a description of an application
type SimpleApp struct {
	Attributes *SimpleAppAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the application (same as 'name')
	ID string `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SimpleApp type instance.
func (ut *SimpleApp) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "application") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"application"}))
	}
	return
}

// a description of an application
type simpleAppAttributes struct {
	Deployments []*simpleDeployment `form:"deployments,omitempty" json:"deployments,omitempty" xml:"deployments,omitempty"`
	Name        *string             `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Validate validates the simpleAppAttributes type instance.
func (ut *simpleAppAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Deployments == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "deployments"))
	}
	for _, e := range ut.Deployments {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates SimpleAppAttributes from simpleAppAttributes
func (ut *simpleAppAttributes) Publicize() *SimpleAppAttributes {
	var pub SimpleAppAttributes
	if ut.Deployments != nil {
		pub.Deployments = make([]*SimpleDeployment, len(ut.Deployments))
		for i2, elem2 := range ut.Deployments {
			pub.Deployments[i2] = elem2.Publicize()
		}
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// a description of an application
type SimpleAppAttributes struct {
	Deployments []*SimpleDeployment `form:"deployments" json:"deployments" xml:"deployments"`
	Name        string              `form:"name" json:"name" xml:"name"`
}

// Validate validates the SimpleAppAttributes type instance.
func (ut *SimpleAppAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Deployments == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "deployments"))
	}
	for _, e := range ut.Deployments {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// a deployment (a step in a pipeline, e.g. 'build')
type simpleDeployment struct {
	Attributes *simpleDeploymentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the deployment (same as 'name')
	ID    *string                    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinksForDeployment `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the simpleDeployment type instance.
func (ut *simpleDeployment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "deployment") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"deployment"}))
		}
	}
	return
}

// Publicize creates SimpleDeployment from simpleDeployment
func (ut *simpleDeployment) Publicize() *SimpleDeployment {
	var pub SimpleDeployment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a deployment (a step in a pipeline, e.g. 'build')
type SimpleDeployment struct {
	Attributes *SimpleDeploymentAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the deployment (same as 'name')
	ID    string                     `form:"id" json:"id" xml:"id"`
	Links *GenericLinksForDeployment `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SimpleDeployment type instance.
func (ut *SimpleDeployment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "deployment") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"deployment"}))
	}
	return
}

// a deployment (a step in a pipeline, e.g. 'build')
type simpleDeploymentAttributes struct {
	ID        *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Name      *string    `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	PodTotal  *int       `form:"pod_total,omitempty" json:"pod_total,omitempty" xml:"pod_total,omitempty"`
	Pods      [][]string `form:"pods,omitempty" json:"pods,omitempty" xml:"pods,omitempty"`
	PodsQuota *podsQuota `form:"pods_quota,omitempty" json:"pods_quota,omitempty" xml:"pods_quota,omitempty"`
	Version   *string    `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the simpleDeploymentAttributes type instance.
func (ut *simpleDeploymentAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Pods == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "pods"))
	}
	return
}

// Publicize creates SimpleDeploymentAttributes from simpleDeploymentAttributes
func (ut *simpleDeploymentAttributes) Publicize() *SimpleDeploymentAttributes {
	var pub SimpleDeploymentAttributes
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.PodTotal != nil {
		pub.PodTotal = ut.PodTotal
	}
	if ut.Pods != nil {
		pub.Pods = ut.Pods
	}
	if ut.PodsQuota != nil {
		pub.PodsQuota = ut.PodsQuota.Publicize()
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// a deployment (a step in a pipeline, e.g. 'build')
type SimpleDeploymentAttributes struct {
	ID        *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Name      string     `form:"name" json:"name" xml:"name"`
	PodTotal  *int       `form:"pod_total,omitempty" json:"pod_total,omitempty" xml:"pod_total,omitempty"`
	Pods      [][]string `form:"pods" json:"pods" xml:"pods"`
	PodsQuota *PodsQuota `form:"pods_quota,omitempty" json:"pods_quota,omitempty" xml:"pods_quota,omitempty"`
	Version   *string    `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the SimpleDeploymentAttributes type instance.
func (ut *SimpleDeploymentAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Pods == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "pods"))
	}
	return
}

// pod limit range
type simpleDeploymentPodLimitRange struct {
	Limits *podsQuota `form:"limits,omitempty" json:"limits,omitempty" xml:"limits,omitempty"`
}

// Publicize creates SimpleDeploymentPodLimitRange from simpleDeploymentPodLimitRange
func (ut *simpleDeploymentPodLimitRange) Publicize() *SimpleDeploymentPodLimitRange {
	var pub SimpleDeploymentPodLimitRange
	if ut.Limits != nil {
		pub.Limits = ut.Limits.Publicize()
	}
	return &pub
}

// pod limit range
type SimpleDeploymentPodLimitRange struct {
	Limits *PodsQuota `form:"limits,omitempty" json:"limits,omitempty" xml:"limits,omitempty"`
}

// pod stat series
type simpleDeploymentStatSeries struct {
	Cores  []*timedNumberTuple `form:"cores,omitempty" json:"cores,omitempty" xml:"cores,omitempty"`
	End    *float64            `form:"end,omitempty" json:"end,omitempty" xml:"end,omitempty"`
	Memory []*timedNumberTuple `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	NetRx  []*timedNumberTuple `form:"net_rx,omitempty" json:"net_rx,omitempty" xml:"net_rx,omitempty"`
	NetTx  []*timedNumberTuple `form:"net_tx,omitempty" json:"net_tx,omitempty" xml:"net_tx,omitempty"`
	Start  *float64            `form:"start,omitempty" json:"start,omitempty" xml:"start,omitempty"`
}

// Publicize creates SimpleDeploymentStatSeries from simpleDeploymentStatSeries
func (ut *simpleDeploymentStatSeries) Publicize() *SimpleDeploymentStatSeries {
	var pub SimpleDeploymentStatSeries
	if ut.Cores != nil {
		pub.Cores = make([]*TimedNumberTuple, len(ut.Cores))
		for i2, elem2 := range ut.Cores {
			pub.Cores[i2] = elem2.Publicize()
		}
	}
	if ut.End != nil {
		pub.End = ut.End
	}
	if ut.Memory != nil {
		pub.Memory = make([]*TimedNumberTuple, len(ut.Memory))
		for i2, elem2 := range ut.Memory {
			pub.Memory[i2] = elem2.Publicize()
		}
	}
	if ut.NetRx != nil {
		pub.NetRx = make([]*TimedNumberTuple, len(ut.NetRx))
		for i2, elem2 := range ut.NetRx {
			pub.NetRx[i2] = elem2.Publicize()
		}
	}
	if ut.NetTx != nil {
		pub.NetTx = make([]*TimedNumberTuple, len(ut.NetTx))
		for i2, elem2 := range ut.NetTx {
			pub.NetTx[i2] = elem2.Publicize()
		}
	}
	if ut.Start != nil {
		pub.Start = ut.Start
	}
	return &pub
}

// pod stat series
type SimpleDeploymentStatSeries struct {
	Cores  []*TimedNumberTuple `form:"cores,omitempty" json:"cores,omitempty" xml:"cores,omitempty"`
	End    *float64            `form:"end,omitempty" json:"end,omitempty" xml:"end,omitempty"`
	Memory []*TimedNumberTuple `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	NetRx  []*TimedNumberTuple `form:"net_rx,omitempty" json:"net_rx,omitempty" xml:"net_rx,omitempty"`
	NetTx  []*TimedNumberTuple `form:"net_tx,omitempty" json:"net_tx,omitempty" xml:"net_tx,omitempty"`
	Start  *float64            `form:"start,omitempty" json:"start,omitempty" xml:"start,omitempty"`
}

// current deployment stats
type simpleDeploymentStats struct {
	Attributes *simpleDeploymentStatsAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the deployment (same as 'name')
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the simpleDeploymentStats type instance.
func (ut *simpleDeploymentStats) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "deploymentstats") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"deploymentstats"}))
		}
	}
	return
}

// Publicize creates SimpleDeploymentStats from simpleDeploymentStats
func (ut *simpleDeploymentStats) Publicize() *SimpleDeploymentStats {
	var pub SimpleDeploymentStats
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// current deployment stats
type SimpleDeploymentStats struct {
	Attributes *SimpleDeploymentStatsAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the deployment (same as 'name')
	ID string `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SimpleDeploymentStats type instance.
func (ut *SimpleDeploymentStats) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if !(ut.Type == "deploymentstats") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"deploymentstats"}))
	}
	return
}

// current deployment stats
type simpleDeploymentStatsAttributes struct {
	Cores  *timedNumberTuple `form:"cores,omitempty" json:"cores,omitempty" xml:"cores,omitempty"`
	Memory *timedNumberTuple `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	NetRx  *timedNumberTuple `form:"net_rx,omitempty" json:"net_rx,omitempty" xml:"net_rx,omitempty"`
	NetTx  *timedNumberTuple `form:"net_tx,omitempty" json:"net_tx,omitempty" xml:"net_tx,omitempty"`
}

// Publicize creates SimpleDeploymentStatsAttributes from simpleDeploymentStatsAttributes
func (ut *simpleDeploymentStatsAttributes) Publicize() *SimpleDeploymentStatsAttributes {
	var pub SimpleDeploymentStatsAttributes
	if ut.Cores != nil {
		pub.Cores = ut.Cores.Publicize()
	}
	if ut.Memory != nil {
		pub.Memory = ut.Memory.Publicize()
	}
	if ut.NetRx != nil {
		pub.NetRx = ut.NetRx.Publicize()
	}
	if ut.NetTx != nil {
		pub.NetTx = ut.NetTx.Publicize()
	}
	return &pub
}

// current deployment stats
type SimpleDeploymentStatsAttributes struct {
	Cores  *TimedNumberTuple `form:"cores,omitempty" json:"cores,omitempty" xml:"cores,omitempty"`
	Memory *TimedNumberTuple `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
	NetRx  *TimedNumberTuple `form:"net_rx,omitempty" json:"net_rx,omitempty" xml:"net_rx,omitempty"`
	NetTx  *TimedNumberTuple `form:"net_tx,omitempty" json:"net_tx,omitempty" xml:"net_tx,omitempty"`
}

// a shared environment
type simpleEnvironment struct {
	Attributes *simpleEnvironmentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the environment (same as 'name')
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the simpleEnvironment type instance.
func (ut *simpleEnvironment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "environment") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"environment"}))
		}
	}
	return
}

// Publicize creates SimpleEnvironment from simpleEnvironment
func (ut *simpleEnvironment) Publicize() *SimpleEnvironment {
	var pub SimpleEnvironment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a shared environment
type SimpleEnvironment struct {
	Attributes *SimpleEnvironmentAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the environment (same as 'name')
	ID string `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SimpleEnvironment type instance.
func (ut *SimpleEnvironment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if !(ut.Type == "environment") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"environment"}))
	}
	return
}

// a shared environment
type simpleEnvironmentAttributes struct {
	Name  *string   `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Quota *envStats `form:"quota,omitempty" json:"quota,omitempty" xml:"quota,omitempty"`
}

// Publicize creates SimpleEnvironmentAttributes from simpleEnvironmentAttributes
func (ut *simpleEnvironmentAttributes) Publicize() *SimpleEnvironmentAttributes {
	var pub SimpleEnvironmentAttributes
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Quota != nil {
		pub.Quota = ut.Quota.Publicize()
	}
	return &pub
}

// a shared environment
type SimpleEnvironmentAttributes struct {
	Name  *string   `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Quota *EnvStats `form:"quota,omitempty" json:"quota,omitempty" xml:"quota,omitempty"`
}

// a space consisting of multiple applications
type simpleSpace struct {
	Attributes *simpleSpaceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the space
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Finalize sets the default values for simpleSpace type instance.
func (ut *simpleSpace) Finalize() {
	var defaultType = "space"
	if ut.Type == nil {
		ut.Type = &defaultType
	}
}

// Validate validates the simpleSpace type instance.
func (ut *simpleSpace) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "space") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"space"}))
		}
	}
	return
}

// Publicize creates SimpleSpace from simpleSpace
func (ut *simpleSpace) Publicize() *SimpleSpace {
	var pub SimpleSpace
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a space consisting of multiple applications
type SimpleSpace struct {
	Attributes *SimpleSpaceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the space
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SimpleSpace type instance.
func (ut *SimpleSpace) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "space") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"space"}))
	}
	return
}

// a space consisting of multiple applications
type simpleSpaceAttributes struct {
	Applications []*simpleApp `form:"applications,omitempty" json:"applications,omitempty" xml:"applications,omitempty"`
	Name         *string      `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Validate validates the simpleSpaceAttributes type instance.
func (ut *simpleSpaceAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Applications == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "applications"))
	}
	for _, e := range ut.Applications {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates SimpleSpaceAttributes from simpleSpaceAttributes
func (ut *simpleSpaceAttributes) Publicize() *SimpleSpaceAttributes {
	var pub SimpleSpaceAttributes
	if ut.Applications != nil {
		pub.Applications = make([]*SimpleApp, len(ut.Applications))
		for i2, elem2 := range ut.Applications {
			pub.Applications[i2] = elem2.Publicize()
		}
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// a space consisting of multiple applications
type SimpleSpaceAttributes struct {
	Applications []*SimpleApp `form:"applications" json:"applications" xml:"applications"`
	Name         string       `form:"name" json:"name" xml:"name"`
}

// Validate validates the SimpleSpaceAttributes type instance.
func (ut *SimpleSpaceAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Applications == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "applications"))
	}
	for _, e := range ut.Applications {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// space user type.
type space struct {
	Attributes *spaceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the space
	ID            *uuid.UUID            `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinksForSpace `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *spaceRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the space type instance.
func (ut *space) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Links != nil {
		if err2 := ut.Links.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// Publicize creates Space from space
func (ut *space) Publicize() *Space {
	var pub Space
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// Space user type.
type Space struct {
	Attributes *SpaceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the space
	ID            *uuid.UUID            `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinksForSpace `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *SpaceRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Space type instance.
func (ut *Space) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "spaces") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"spaces"}))
	}
	return
}

// Environment usage by specific space and all others
type spaceAndOtherEnvironmentUsage struct {
	Attributes *spaceAndOtherEnvironmentUsageAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the environment (same as 'name')
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the spaceAndOtherEnvironmentUsage type instance.
func (ut *spaceAndOtherEnvironmentUsage) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "environment") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"environment"}))
		}
	}
	return
}

// Publicize creates SpaceAndOtherEnvironmentUsage from spaceAndOtherEnvironmentUsage
func (ut *spaceAndOtherEnvironmentUsage) Publicize() *SpaceAndOtherEnvironmentUsage {
	var pub SpaceAndOtherEnvironmentUsage
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// Environment usage by specific space and all others
type SpaceAndOtherEnvironmentUsage struct {
	Attributes *SpaceAndOtherEnvironmentUsageAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the environment (same as 'name')
	ID string `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SpaceAndOtherEnvironmentUsage type instance.
func (ut *SpaceAndOtherEnvironmentUsage) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if !(ut.Type == "environment") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"environment"}))
	}
	return
}

// Attributes for environment usage info for a single space
type spaceAndOtherEnvironmentUsageAttributes struct {
	Name       *string                     `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	OtherUsage *envStats                   `form:"other_usage,omitempty" json:"other_usage,omitempty" xml:"other_usage,omitempty"`
	SpaceUsage *spaceEnvironmentUsageQuota `form:"space_usage,omitempty" json:"space_usage,omitempty" xml:"space_usage,omitempty"`
}

// Publicize creates SpaceAndOtherEnvironmentUsageAttributes from spaceAndOtherEnvironmentUsageAttributes
func (ut *spaceAndOtherEnvironmentUsageAttributes) Publicize() *SpaceAndOtherEnvironmentUsageAttributes {
	var pub SpaceAndOtherEnvironmentUsageAttributes
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.OtherUsage != nil {
		pub.OtherUsage = ut.OtherUsage.Publicize()
	}
	if ut.SpaceUsage != nil {
		pub.SpaceUsage = ut.SpaceUsage.Publicize()
	}
	return &pub
}

// Attributes for environment usage info for a single space
type SpaceAndOtherEnvironmentUsageAttributes struct {
	Name       *string                     `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	OtherUsage *EnvStats                   `form:"other_usage,omitempty" json:"other_usage,omitempty" xml:"other_usage,omitempty"`
	SpaceUsage *SpaceEnvironmentUsageQuota `form:"space_usage,omitempty" json:"space_usage,omitempty" xml:"space_usage,omitempty"`
}

// spaceAttributes user type.
type spaceAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description for the space
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name for the space
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the spaceAttributes type instance.
func (ut *spaceAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Publicize creates SpaceAttributes from spaceAttributes
func (ut *spaceAttributes) Publicize() *SpaceAttributes {
	var pub SpaceAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// SpaceAttributes user type.
type SpaceAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description for the space
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name for the space
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the SpaceAttributes type instance.
func (ut *SpaceAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Quota info for space-aware environment usage
type spaceEnvironmentUsageQuota struct {
	Cpucores *float64 `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	Memory   *float64 `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
}

// Publicize creates SpaceEnvironmentUsageQuota from spaceEnvironmentUsageQuota
func (ut *spaceEnvironmentUsageQuota) Publicize() *SpaceEnvironmentUsageQuota {
	var pub SpaceEnvironmentUsageQuota
	if ut.Cpucores != nil {
		pub.Cpucores = ut.Cpucores
	}
	if ut.Memory != nil {
		pub.Memory = ut.Memory
	}
	return &pub
}

// Quota info for space-aware environment usage
type SpaceEnvironmentUsageQuota struct {
	Cpucores *float64 `form:"cpucores,omitempty" json:"cpucores,omitempty" xml:"cpucores,omitempty"`
	Memory   *float64 `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
}

// spaceListMeta user type.
type spaceListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the spaceListMeta type instance.
func (ut *spaceListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates SpaceListMeta from spaceListMeta
func (ut *spaceListMeta) Publicize() *SpaceListMeta {
	var pub SpaceListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// SpaceListMeta user type.
type SpaceListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// spaceOwnedBy user type.
type spaceOwnedBy struct {
	Data  *identityRelationData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the spaceOwnedBy type instance.
func (ut *spaceOwnedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates SpaceOwnedBy from spaceOwnedBy
func (ut *spaceOwnedBy) Publicize() *SpaceOwnedBy {
	var pub SpaceOwnedBy
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// SpaceOwnedBy user type.
type SpaceOwnedBy struct {
	Data  *IdentityRelationData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the SpaceOwnedBy type instance.
func (ut *SpaceOwnedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// spaceRelationships user type.
type spaceRelationships struct {
	// Space can have one or many areas
	Areas *relationGeneric `form:"areas,omitempty" json:"areas,omitempty" xml:"areas,omitempty"`
	// Space can have a backlog
	Backlog *relationGeneric `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// Space can have one or many codebases
	Codebases *relationGeneric `form:"codebases,omitempty" json:"codebases,omitempty" xml:"codebases,omitempty"`
	// Space can have one or many collaborators
	Collaborators *relationGeneric `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// Space can have one or many filters
	Filters *relationGeneric `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	// Space can have one or many iterations
	Iterations *relationGeneric `form:"iterations,omitempty" json:"iterations,omitempty" xml:"iterations,omitempty"`
	// Space can have one or many labels
	Labels *relationGeneric `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// The owner of the Space
	OwnedBy *spaceOwnedBy `form:"owned-by,omitempty" json:"owned-by,omitempty" xml:"owned-by,omitempty"`
	// Space is constructed from a space template
	SpaceTemplate *spaceTemplateRelation `form:"space-template,omitempty" json:"space-template,omitempty" xml:"space-template,omitempty"`
	// (OBSOLETE) Space can have one or many work item link types
	Workitemlinktypes *relationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space can have one or many work items
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
	// (OBSOLETE) Space can have one or many work item type groups
	Workitemtypegroups *relationGeneric `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// (OBSOLETE) Space can have one or many work item types
	Workitemtypes *relationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the spaceRelationships type instance.
func (ut *spaceRelationships) Validate() (err error) {
	if ut.OwnedBy != nil {
		if err2 := ut.OwnedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates SpaceRelationships from spaceRelationships
func (ut *spaceRelationships) Publicize() *SpaceRelationships {
	var pub SpaceRelationships
	if ut.Areas != nil {
		pub.Areas = ut.Areas.Publicize()
	}
	if ut.Backlog != nil {
		pub.Backlog = ut.Backlog.Publicize()
	}
	if ut.Codebases != nil {
		pub.Codebases = ut.Codebases.Publicize()
	}
	if ut.Collaborators != nil {
		pub.Collaborators = ut.Collaborators.Publicize()
	}
	if ut.Filters != nil {
		pub.Filters = ut.Filters.Publicize()
	}
	if ut.Iterations != nil {
		pub.Iterations = ut.Iterations.Publicize()
	}
	if ut.Labels != nil {
		pub.Labels = ut.Labels.Publicize()
	}
	if ut.OwnedBy != nil {
		pub.OwnedBy = ut.OwnedBy.Publicize()
	}
	if ut.SpaceTemplate != nil {
		pub.SpaceTemplate = ut.SpaceTemplate.Publicize()
	}
	if ut.Workitemlinktypes != nil {
		pub.Workitemlinktypes = ut.Workitemlinktypes.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	if ut.Workitemtypegroups != nil {
		pub.Workitemtypegroups = ut.Workitemtypegroups.Publicize()
	}
	if ut.Workitemtypes != nil {
		pub.Workitemtypes = ut.Workitemtypes.Publicize()
	}
	return &pub
}

// SpaceRelationships user type.
type SpaceRelationships struct {
	// Space can have one or many areas
	Areas *RelationGeneric `form:"areas,omitempty" json:"areas,omitempty" xml:"areas,omitempty"`
	// Space can have a backlog
	Backlog *RelationGeneric `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// Space can have one or many codebases
	Codebases *RelationGeneric `form:"codebases,omitempty" json:"codebases,omitempty" xml:"codebases,omitempty"`
	// Space can have one or many collaborators
	Collaborators *RelationGeneric `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// Space can have one or many filters
	Filters *RelationGeneric `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	// Space can have one or many iterations
	Iterations *RelationGeneric `form:"iterations,omitempty" json:"iterations,omitempty" xml:"iterations,omitempty"`
	// Space can have one or many labels
	Labels *RelationGeneric `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// The owner of the Space
	OwnedBy *SpaceOwnedBy `form:"owned-by,omitempty" json:"owned-by,omitempty" xml:"owned-by,omitempty"`
	// Space is constructed from a space template
	SpaceTemplate *SpaceTemplateRelation `form:"space-template,omitempty" json:"space-template,omitempty" xml:"space-template,omitempty"`
	// (OBSOLETE) Space can have one or many work item link types
	Workitemlinktypes *RelationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space can have one or many work items
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
	// (OBSOLETE) Space can have one or many work item type groups
	Workitemtypegroups *RelationGeneric `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// (OBSOLETE) Space can have one or many work item types
	Workitemtypes *RelationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the SpaceRelationships type instance.
func (ut *SpaceRelationships) Validate() (err error) {
	if ut.OwnedBy != nil {
		if err2 := ut.OwnedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for the data of a space template. See also http://jsonapi.org/format/#document-resource-object
type spaceTemplate struct {
	Attributes *spaceTemplateAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of space template
	ID            *uuid.UUID                  `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks               `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *spaceTemplateRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                     `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the spaceTemplate type instance.
func (ut *spaceTemplate) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "spacetemplates") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"spacetemplates"}))
		}
	}
	return
}

// Publicize creates SpaceTemplate from spaceTemplate
func (ut *spaceTemplate) Publicize() *SpaceTemplate {
	var pub SpaceTemplate
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a space template. See also http://jsonapi.org/format/#document-resource-object
type SpaceTemplate struct {
	Attributes *SpaceTemplateAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of space template
	ID            *uuid.UUID                  `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks               `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *SpaceTemplateRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                      `form:"type" json:"type" xml:"type"`
}

// Validate validates the SpaceTemplate type instance.
func (ut *SpaceTemplate) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "spacetemplates") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"spacetemplates"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a space template. See also see http://jsonapi.org/format/#document-resource-object-attributes
type spaceTemplateAttributes struct {
	// Whether or not this space template type is supposed to be used for creating spaces directly.
	CanConstruct *bool `form:"can-construct,omitempty" json:"can-construct,omitempty" xml:"can-construct,omitempty"`
	// When the space template was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// optional description of the space template
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// name of the space template.
	//  This is MANDATORY on creation of resource.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space template was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the spaceTemplateAttributes type instance.
func (ut *spaceTemplateAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates SpaceTemplateAttributes from spaceTemplateAttributes
func (ut *spaceTemplateAttributes) Publicize() *SpaceTemplateAttributes {
	var pub SpaceTemplateAttributes
	if ut.CanConstruct != nil {
		pub.CanConstruct = ut.CanConstruct
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a space template. See also see http://jsonapi.org/format/#document-resource-object-attributes
type SpaceTemplateAttributes struct {
	// Whether or not this space template type is supposed to be used for creating spaces directly.
	CanConstruct *bool `form:"can-construct,omitempty" json:"can-construct,omitempty" xml:"can-construct,omitempty"`
	// When the space template was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// optional description of the space template
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// name of the space template.
	//  This is MANDATORY on creation of resource.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space template was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the SpaceTemplateAttributes type instance.
func (ut *SpaceTemplateAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// spaceTemplateRelation user type.
type spaceTemplateRelation struct {
	Data  *spaceTemplateRelationData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the spaceTemplateRelation type instance.
func (ut *spaceTemplateRelation) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates SpaceTemplateRelation from spaceTemplateRelation
func (ut *spaceTemplateRelation) Publicize() *SpaceTemplateRelation {
	var pub SpaceTemplateRelation
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// SpaceTemplateRelation user type.
type SpaceTemplateRelation struct {
	Data  *SpaceTemplateRelationData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the SpaceTemplateRelation type instance.
func (ut *SpaceTemplateRelation) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// spaceTemplateRelationData user type.
type spaceTemplateRelationData struct {
	// unique id of the space template
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the spaceTemplateRelationData type instance.
func (ut *spaceTemplateRelationData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "spacetemplates") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"spacetemplates"}))
		}
	}
	return
}

// Publicize creates SpaceTemplateRelationData from spaceTemplateRelationData
func (ut *spaceTemplateRelationData) Publicize() *SpaceTemplateRelationData {
	var pub SpaceTemplateRelationData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// SpaceTemplateRelationData user type.
type SpaceTemplateRelationData struct {
	// unique id of the space template
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the SpaceTemplateRelationData type instance.
func (ut *SpaceTemplateRelationData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	if !(ut.Type == "spacetemplates") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"spacetemplates"}))
	}
	return
}

// spaceTemplateRelationships user type.
type spaceTemplateRelationships struct {
	// Space template can have one or maximum count of work item type groups boards
	Workitemboards *relationGeneric `form:"workitemboards,omitempty" json:"workitemboards,omitempty" xml:"workitemboards,omitempty"`
	// Space template can have one or many work item link types
	Workitemlinktypes *relationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space template can have one or many work item type groups
	Workitemtypegroups *relationGeneric `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// Space template can have one or many work item types
	Workitemtypes *relationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Publicize creates SpaceTemplateRelationships from spaceTemplateRelationships
func (ut *spaceTemplateRelationships) Publicize() *SpaceTemplateRelationships {
	var pub SpaceTemplateRelationships
	if ut.Workitemboards != nil {
		pub.Workitemboards = ut.Workitemboards.Publicize()
	}
	if ut.Workitemlinktypes != nil {
		pub.Workitemlinktypes = ut.Workitemlinktypes.Publicize()
	}
	if ut.Workitemtypegroups != nil {
		pub.Workitemtypegroups = ut.Workitemtypegroups.Publicize()
	}
	if ut.Workitemtypes != nil {
		pub.Workitemtypes = ut.Workitemtypes.Publicize()
	}
	return &pub
}

// SpaceTemplateRelationships user type.
type SpaceTemplateRelationships struct {
	// Space template can have one or maximum count of work item type groups boards
	Workitemboards *RelationGeneric `form:"workitemboards,omitempty" json:"workitemboards,omitempty" xml:"workitemboards,omitempty"`
	// Space template can have one or many work item link types
	Workitemlinktypes *RelationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space template can have one or many work item type groups
	Workitemtypegroups *RelationGeneric `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// Space template can have one or many work item types
	Workitemtypes *RelationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// a set of time and number values
type timedNumberTuple struct {
	Time  *float64 `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Publicize creates TimedNumberTuple from timedNumberTuple
func (ut *timedNumberTuple) Publicize() *TimedNumberTuple {
	var pub TimedNumberTuple
	if ut.Time != nil {
		pub.Time = ut.Time
	}
	if ut.Value != nil {
		pub.Value = ut.Value
	}
	return &pub
}

// a set of time and number values
type TimedNumberTuple struct {
	Time  *float64 `form:"time,omitempty" json:"time,omitempty" xml:"time,omitempty"`
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// tokenData user type.
type tokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn *interface{} `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// Token is not valid if issued before this date
	NotBeforePolicy *interface{} `form:"not-before-policy,omitempty" json:"not-before-policy,omitempty" xml:"not-before-policy,omitempty"`
	// Refresh token expires in seconds
	RefreshExpiresIn *interface{} `form:"refresh_expires_in,omitempty" json:"refresh_expires_in,omitempty" xml:"refresh_expires_in,omitempty"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the tokenData type instance.
func (ut *tokenData) Validate() (err error) {
	if ut.ExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "expires_in"))
	}
	if ut.RefreshExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "refresh_expires_in"))
	}
	if ut.NotBeforePolicy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "not-before-policy"))
	}
	return
}

// Publicize creates TokenData from tokenData
func (ut *tokenData) Publicize() *TokenData {
	var pub TokenData
	if ut.AccessToken != nil {
		pub.AccessToken = ut.AccessToken
	}
	if ut.ExpiresIn != nil {
		pub.ExpiresIn = *ut.ExpiresIn
	}
	if ut.NotBeforePolicy != nil {
		pub.NotBeforePolicy = *ut.NotBeforePolicy
	}
	if ut.RefreshExpiresIn != nil {
		pub.RefreshExpiresIn = *ut.RefreshExpiresIn
	}
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	if ut.TokenType != nil {
		pub.TokenType = ut.TokenType
	}
	return &pub
}

// TokenData user type.
type TokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn interface{} `form:"expires_in" json:"expires_in" xml:"expires_in"`
	// Token is not valid if issued before this date
	NotBeforePolicy interface{} `form:"not-before-policy" json:"not-before-policy" xml:"not-before-policy"`
	// Refresh token expires in seconds
	RefreshExpiresIn interface{} `form:"refresh_expires_in" json:"refresh_expires_in" xml:"refresh_expires_in"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the TokenData type instance.
func (ut *TokenData) Validate() (err error) {

	return
}

// JSONAPI store for the data of a Tracker. See also http://jsonapi.org/format/#document-resource-object
type tracker struct {
	Attributes *trackerAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of tracker
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *trackerRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string           `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the tracker type instance.
func (ut *tracker) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "trackers") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"trackers"}))
		}
	}
	return
}

// Publicize creates Tracker from tracker
func (ut *tracker) Publicize() *Tracker {
	var pub Tracker
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Tracker. See also http://jsonapi.org/format/#document-resource-object
type Tracker struct {
	Attributes *TrackerAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of tracker
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *TrackerRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string            `form:"type" json:"type" xml:"type"`
}

// Validate validates the Tracker type instance.
func (ut *Tracker) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "trackers") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"trackers"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Tracker. See also http://jsonapi.org/format/#document-resource-object-attributes
type trackerAttributes struct {
	// Type of the tracker
	Type *string `form:"Type,omitempty" json:"Type,omitempty" xml:"Type,omitempty"`
	// URL of the tracker
	URL *string `form:"URL,omitempty" json:"URL,omitempty" xml:"URL,omitempty"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Validate validates the trackerAttributes type instance.
func (ut *trackerAttributes) Validate() (err error) {
	if ut.URL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "URL"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "Type"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "github" || *ut.Type == "jira") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.Type`, *ut.Type, []interface{}{"github", "jira"}))
		}
	}
	return
}

// Publicize creates TrackerAttributes from trackerAttributes
func (ut *trackerAttributes) Publicize() *TrackerAttributes {
	var pub TrackerAttributes
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	if ut.URL != nil {
		pub.URL = *ut.URL
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Tracker. See also http://jsonapi.org/format/#document-resource-object-attributes
type TrackerAttributes struct {
	// Type of the tracker
	Type string `form:"Type" json:"Type" xml:"Type"`
	// URL of the tracker
	URL string `form:"URL" json:"URL" xml:"URL"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Validate validates the TrackerAttributes type instance.
func (ut *TrackerAttributes) Validate() (err error) {
	if ut.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "URL"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "Type"))
	}
	if !(ut.Type == "github" || ut.Type == "jira") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.Type`, ut.Type, []interface{}{"github", "jira"}))
	}
	return
}

// trackerQueryRelationships user type.
type trackerQueryRelationships struct {
	// This defines the owning space of this work item type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the trackerQueryRelationships type instance.
func (ut *trackerQueryRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates TrackerQueryRelationships from trackerQueryRelationships
func (ut *trackerQueryRelationships) Publicize() *TrackerQueryRelationships {
	var pub TrackerQueryRelationships
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// TrackerQueryRelationships user type.
type TrackerQueryRelationships struct {
	// This defines the owning space of this work item type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the TrackerQueryRelationships type instance.
func (ut *TrackerQueryRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// trackerRelations user type.
type trackerRelations struct {
}

// Publicize creates TrackerRelations from trackerRelations
func (ut *trackerRelations) Publicize() *TrackerRelations {
	var pub TrackerRelations

	return &pub
}

// TrackerRelations user type.
type TrackerRelations struct {
}

// updateIdentityDataAttributes user type.
type updateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UpdateIdentityDataAttributes from updateIdentityDataAttributes
func (ut *updateIdentityDataAttributes) Publicize() *UpdateIdentityDataAttributes {
	var pub UpdateIdentityDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UpdateIdentityDataAttributes user type.
type UpdateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// updateTrackerQueryAlternatePayload user type.
type updateTrackerQueryAlternatePayload struct {
	// Search query
	Query         *string                    `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	Relationships *trackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule *string `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Tracker ID
	TrackerID *uuid.UUID `form:"trackerID,omitempty" json:"trackerID,omitempty" xml:"trackerID,omitempty"`
}

// Validate validates the updateTrackerQueryAlternatePayload type instance.
func (ut *updateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "query"))
	}
	if ut.Schedule == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "schedule"))
	}
	if ut.TrackerID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "trackerID"))
	}
	if ut.Query != nil {
		if utf8.RuneCountInString(*ut.Query) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.query`, *ut.Query, utf8.RuneCountInString(*ut.Query), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Schedule != nil {
		if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, *ut.Schedule); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.schedule`, *ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
		}
	}
	if ut.Schedule != nil {
		if utf8.RuneCountInString(*ut.Schedule) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.schedule`, *ut.Schedule, utf8.RuneCountInString(*ut.Schedule), 1, true))
		}
	}
	return
}

// Publicize creates UpdateTrackerQueryAlternatePayload from updateTrackerQueryAlternatePayload
func (ut *updateTrackerQueryAlternatePayload) Publicize() *UpdateTrackerQueryAlternatePayload {
	var pub UpdateTrackerQueryAlternatePayload
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Schedule != nil {
		pub.Schedule = *ut.Schedule
	}
	if ut.TrackerID != nil {
		pub.TrackerID = *ut.TrackerID
	}
	return &pub
}

// UpdateTrackerQueryAlternatePayload user type.
type UpdateTrackerQueryAlternatePayload struct {
	// Search query
	Query         string                     `form:"query" json:"query" xml:"query"`
	Relationships *TrackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule string `form:"schedule" json:"schedule" xml:"schedule"`
	// Tracker ID
	TrackerID uuid.UUID `form:"trackerID" json:"trackerID" xml:"trackerID"`
}

// Validate validates the UpdateTrackerQueryAlternatePayload type instance.
func (ut *UpdateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "query"))
	}
	if ut.Schedule == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "schedule"))
	}

	if utf8.RuneCountInString(ut.Query) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.query`, ut.Query, utf8.RuneCountInString(ut.Query), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, ut.Schedule); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.schedule`, ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
	}
	if utf8.RuneCountInString(ut.Schedule) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.schedule`, ut.Schedule, utf8.RuneCountInString(ut.Schedule), 1, true))
	}
	return
}

// updateUserData user type.
type updateUserData struct {
	// Attributes of the user identity
	Attributes *updateIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserData type instance.
func (ut *updateUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	return
}

// Publicize creates UpdateUserData from updateUserData
func (ut *updateUserData) Publicize() *UpdateUserData {
	var pub UpdateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UpdateUserData user type.
type UpdateUserData struct {
	// Attributes of the user identity
	Attributes *UpdateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserData type instance.
func (ut *UpdateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	return
}

// updateWorkItemLinkPayload user type.
type updateWorkItemLinkPayload struct {
	Data *workItemLinkData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the updateWorkItemLinkPayload type instance.
func (ut *updateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemLinkPayload from updateWorkItemLinkPayload
func (ut *updateWorkItemLinkPayload) Publicize() *UpdateWorkItemLinkPayload {
	var pub UpdateWorkItemLinkPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// UpdateWorkItemLinkPayload user type.
type UpdateWorkItemLinkPayload struct {
	Data *WorkItemLinkData `form:"data" json:"data" xml:"data"`
}

// Validate validates the UpdateWorkItemLinkPayload type instance.
func (ut *UpdateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateWorkItemLinkTypePayload user type.
type updateWorkItemLinkTypePayload struct {
	Data *workItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the updateWorkItemLinkTypePayload type instance.
func (ut *updateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemLinkTypePayload from updateWorkItemLinkTypePayload
func (ut *updateWorkItemLinkTypePayload) Publicize() *UpdateWorkItemLinkTypePayload {
	var pub UpdateWorkItemLinkTypePayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// UpdateWorkItemLinkTypePayload user type.
type UpdateWorkItemLinkTypePayload struct {
	Data *WorkItemLinkTypeData `form:"data" json:"data" xml:"data"`
}

// Validate validates the UpdateWorkItemLinkTypePayload type instance.
func (ut *UpdateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateWorkItemPayload user type.
type updateWorkItemPayload struct {
	// The order of execution of workitem
	Executionorder *float64 `form:"executionorder,omitempty" json:"executionorder,omitempty" xml:"executionorder,omitempty"`
	// The field values, must conform to the type
	Fields        map[string]interface{} `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	Relationships *workItemRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// ID of the work item type
	Type *uuid.UUID `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the updateWorkItemPayload type instance.
func (ut *updateWorkItemPayload) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "fields"))
	}
	if ut.Version == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "version"))
	}
	if ut.Executionorder == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "executionorder"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemPayload from updateWorkItemPayload
func (ut *updateWorkItemPayload) Publicize() *UpdateWorkItemPayload {
	var pub UpdateWorkItemPayload
	if ut.Executionorder != nil {
		pub.Executionorder = *ut.Executionorder
	}
	if ut.Fields != nil {
		pub.Fields = ut.Fields
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	if ut.Version != nil {
		pub.Version = *ut.Version
	}
	return &pub
}

// UpdateWorkItemPayload user type.
type UpdateWorkItemPayload struct {
	// The order of execution of workitem
	Executionorder float64 `form:"executionorder" json:"executionorder" xml:"executionorder"`
	// The field values, must conform to the type
	Fields        map[string]interface{} `form:"fields" json:"fields" xml:"fields"`
	Relationships *WorkItemRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// ID of the work item type
	Type uuid.UUID `form:"type" json:"type" xml:"type"`
	// Version for optimistic concurrency control
	Version int `form:"version" json:"version" xml:"version"`
}

// Validate validates the UpdateWorkItemPayload type instance.
func (ut *UpdateWorkItemPayload) Validate() (err error) {

	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "fields"))
	}

	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// userData user type.
type userData struct {
	// Attributes of the user
	Attributes *userDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userData type instance.
func (ut *userData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	return
}

// Publicize creates UserData from userData
func (ut *userData) Publicize() *UserData {
	var pub UserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UserData user type.
type UserData struct {
	// Attributes of the user
	Attributes *UserDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserData type instance.
func (ut *UserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	return
}

// userDataAttributes user type.
type userDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UserDataAttributes from userDataAttributes
func (ut *userDataAttributes) Publicize() *UserDataAttributes {
	var pub UserDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.IdentityID != nil {
		pub.IdentityID = ut.IdentityID
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.UserID != nil {
		pub.UserID = ut.UserID
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UserDataAttributes user type.
type UserDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// JSONAPI for the teant object. See also http://jsonapi.org/format/#document-resource-object
type userService struct {
	Attributes *userServiceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of tenant
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userService type instance.
func (ut *userService) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "userservices") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"userservices"}))
		}
	}
	return
}

// Publicize creates UserService from userService
func (ut *userService) Publicize() *UserService {
	var pub UserService
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI for the teant object. See also http://jsonapi.org/format/#document-resource-object
type UserService struct {
	Attributes *UserServiceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of tenant
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  string        `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserService type instance.
func (ut *UserService) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "userservices") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"userservices"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a UserService. See also see http://jsonapi.org/format/#document-resource-object-attributes
type userServiceAttributes struct {
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The tenant namespaces
	Namespaces []*namespaceAttributes `form:"namespaces,omitempty" json:"namespaces,omitempty" xml:"namespaces,omitempty"`
}

// Validate validates the userServiceAttributes type instance.
func (ut *userServiceAttributes) Validate() (err error) {
	for _, e := range ut.Namespaces {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates UserServiceAttributes from userServiceAttributes
func (ut *userServiceAttributes) Publicize() *UserServiceAttributes {
	var pub UserServiceAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Namespaces != nil {
		pub.Namespaces = make([]*NamespaceAttributes, len(ut.Namespaces))
		for i2, elem2 := range ut.Namespaces {
			pub.Namespaces[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a UserService. See also see http://jsonapi.org/format/#document-resource-object-attributes
type UserServiceAttributes struct {
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The tenant namespaces
	Namespaces []*NamespaceAttributes `form:"namespaces,omitempty" json:"namespaces,omitempty" xml:"namespaces,omitempty"`
}

// Validate validates the UserServiceAttributes type instance.
func (ut *UserServiceAttributes) Validate() (err error) {
	for _, e := range ut.Namespaces {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// userSpacesData user type.
type userSpacesData struct {
	// Info about the role and scopes that the user has in the resource
	Attributes *userSpacesDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// id of the space that in which the user has a role
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userSpacesData type instance.
func (ut *userSpacesData) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UserSpacesData from userSpacesData
func (ut *userSpacesData) Publicize() *UserSpacesData {
	var pub UserSpacesData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UserSpacesData user type.
type UserSpacesData struct {
	// Info about the role and scopes that the user has in the resource
	Attributes *UserSpacesDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// id of the space that in which the user has a role
	ID    string        `form:"id" json:"id" xml:"id"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserSpacesData type instance.
func (ut *UserSpacesData) Validate() (err error) {
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "id"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// userSpacesDataAttributes user type.
type userSpacesDataAttributes struct {
	// The name of the space
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Validate validates the userSpacesDataAttributes type instance.
func (ut *userSpacesDataAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	return
}

// Publicize creates UserSpacesDataAttributes from userSpacesDataAttributes
func (ut *userSpacesDataAttributes) Publicize() *UserSpacesDataAttributes {
	var pub UserSpacesDataAttributes
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// UserSpacesDataAttributes user type.
type UserSpacesDataAttributes struct {
	// The name of the space
	Name string `form:"name" json:"name" xml:"name"`
}

// Validate validates the UserSpacesDataAttributes type instance.
func (ut *UserSpacesDataAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	return
}

// userSpacesListMeta user type.
type userSpacesListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the userSpacesListMeta type instance.
func (ut *userSpacesListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates UserSpacesListMeta from userSpacesListMeta
func (ut *userSpacesListMeta) Publicize() *UserSpacesListMeta {
	var pub UserSpacesListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// UserSpacesListMeta user type.
type UserSpacesListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// workItem user type.
type workItem struct {
	Attributes map[string]interface{} `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the work item which is being updated
	ID            *uuid.UUID               `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinksForWorkItem `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                  `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItem type instance.
func (ut *workItem) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitems") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitems"}))
		}
	}
	return
}

// Publicize creates WorkItem from workItem
func (ut *workItem) Publicize() *WorkItem {
	var pub WorkItem
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// WorkItem user type.
type WorkItem struct {
	Attributes map[string]interface{} `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the work item which is being updated
	ID            *uuid.UUID               `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinksForWorkItem `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                   `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItem type instance.
func (ut *WorkItem) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitems") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitems"}))
	}
	return
}

// workItemBoardAttributes user type.
type workItemBoardAttributes struct {
	// Context of this board
	Context *string `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Type of the context, used in addition to the context value
	ContextType *string `form:"contextType,omitempty" json:"contextType,omitempty" xml:"contextType,omitempty"`
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	Name      *string    `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemBoardAttributes type instance.
func (ut *workItemBoardAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Context == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "context"))
	}
	if ut.ContextType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "contextType"))
	}
	if ut.ContextType != nil {
		if !(*ut.ContextType == "TypeLevelContext") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.contextType`, *ut.ContextType, []interface{}{"TypeLevelContext"}))
		}
	}
	return
}

// Publicize creates WorkItemBoardAttributes from workItemBoardAttributes
func (ut *workItemBoardAttributes) Publicize() *WorkItemBoardAttributes {
	var pub WorkItemBoardAttributes
	if ut.Context != nil {
		pub.Context = *ut.Context
	}
	if ut.ContextType != nil {
		pub.ContextType = *ut.ContextType
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// WorkItemBoardAttributes user type.
type WorkItemBoardAttributes struct {
	// Context of this board
	Context string `form:"context" json:"context" xml:"context"`
	// Type of the context, used in addition to the context value
	ContextType string `form:"contextType" json:"contextType" xml:"contextType"`
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	Name      string     `form:"name" json:"name" xml:"name"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemBoardAttributes type instance.
func (ut *WorkItemBoardAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Context == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "context"))
	}
	if ut.ContextType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "contextType"))
	}
	if !(ut.ContextType == "TypeLevelContext") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.contextType`, ut.ContextType, []interface{}{"TypeLevelContext"}))
	}
	return
}

// workItemBoardColumnAttributes user type.
type workItemBoardColumnAttributes struct {
	Name  *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Order *int    `form:"order,omitempty" json:"order,omitempty" xml:"order,omitempty"`
}

// Validate validates the workItemBoardColumnAttributes type instance.
func (ut *workItemBoardColumnAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	return
}

// Publicize creates WorkItemBoardColumnAttributes from workItemBoardColumnAttributes
func (ut *workItemBoardColumnAttributes) Publicize() *WorkItemBoardColumnAttributes {
	var pub WorkItemBoardColumnAttributes
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.Order != nil {
		pub.Order = ut.Order
	}
	return &pub
}

// WorkItemBoardColumnAttributes user type.
type WorkItemBoardColumnAttributes struct {
	Name  string `form:"name" json:"name" xml:"name"`
	Order *int   `form:"order,omitempty" json:"order,omitempty" xml:"order,omitempty"`
}

// Validate validates the WorkItemBoardColumnAttributes type instance.
func (ut *WorkItemBoardColumnAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	return
}

// a column represents a vertical lane in a board
type workItemBoardColumnData struct {
	Attributes *workItemBoardColumnAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the work item board column
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type string of the work item board column
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemBoardColumnData type instance.
func (ut *workItemBoardColumnData) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "boardcolumns") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"boardcolumns"}))
		}
	}
	return
}

// Publicize creates WorkItemBoardColumnData from workItemBoardColumnData
func (ut *workItemBoardColumnData) Publicize() *WorkItemBoardColumnData {
	var pub WorkItemBoardColumnData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a column represents a vertical lane in a board
type WorkItemBoardColumnData struct {
	Attributes *WorkItemBoardColumnAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the work item board column
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type string of the work item board column
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemBoardColumnData type instance.
func (ut *WorkItemBoardColumnData) Validate() (err error) {

	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "boardcolumns") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"boardcolumns"}))
	}
	return
}

// a board shows different work item type together in a board
type workItemBoardData struct {
	Attributes *workItemBoardAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the work item board
	ID            *uuid.UUID                  `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks               `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemBoardRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type string of the work item board
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemBoardData type instance.
func (ut *workItemBoardData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemboards") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemboards"}))
		}
	}
	return
}

// Publicize creates WorkItemBoardData from workItemBoardData
func (ut *workItemBoardData) Publicize() *WorkItemBoardData {
	var pub WorkItemBoardData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a board shows different work item type together in a board
type WorkItemBoardData struct {
	Attributes *WorkItemBoardAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the work item board
	ID            *uuid.UUID                  `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks               `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemBoardRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type string of the work item board
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemBoardData type instance.
func (ut *WorkItemBoardData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemboards") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemboards"}))
	}
	return
}

// workItemBoardLinks user type.
type workItemBoardLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemBoardLinks type instance.
func (ut *workItemBoardLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemBoardLinks from workItemBoardLinks
func (ut *workItemBoardLinks) Publicize() *WorkItemBoardLinks {
	var pub WorkItemBoardLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemBoardLinks user type.
type WorkItemBoardLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemBoardLinks type instance.
func (ut *WorkItemBoardLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemBoardRelationships user type.
type workItemBoardRelationships struct {
	// List of work item board columns attached to the board
	Columns *relationGenericList `form:"columns,omitempty" json:"columns,omitempty" xml:"columns,omitempty"`
	// The space template to which this board belongs
	SpaceTemplate *relationGeneric `form:"spaceTemplate,omitempty" json:"spaceTemplate,omitempty" xml:"spaceTemplate,omitempty"`
}

// Publicize creates WorkItemBoardRelationships from workItemBoardRelationships
func (ut *workItemBoardRelationships) Publicize() *WorkItemBoardRelationships {
	var pub WorkItemBoardRelationships
	if ut.Columns != nil {
		pub.Columns = ut.Columns.Publicize()
	}
	if ut.SpaceTemplate != nil {
		pub.SpaceTemplate = ut.SpaceTemplate.Publicize()
	}
	return &pub
}

// WorkItemBoardRelationships user type.
type WorkItemBoardRelationships struct {
	// List of work item board columns attached to the board
	Columns *RelationGenericList `form:"columns,omitempty" json:"columns,omitempty" xml:"columns,omitempty"`
	// The space template to which this board belongs
	SpaceTemplate *RelationGeneric `form:"spaceTemplate,omitempty" json:"spaceTemplate,omitempty" xml:"spaceTemplate,omitempty"`
}

// JSONAPI store for all the "attributes" of a work item link.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type workItemLinkAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Publicize creates WorkItemLinkAttributes from workItemLinkAttributes
func (ut *workItemLinkAttributes) Publicize() *WorkItemLinkAttributes {
	var pub WorkItemLinkAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a work item link.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkItemLinkAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// JSONAPI store for the data of a work item.
// See also http://jsonapi.org/format/#document-resource-object
type workItemLinkData struct {
	Attributes *workItemLinkAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemLinkRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemLinkData type instance.
func (ut *workItemLinkData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "relationships"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinks") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemlinks"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkData from workItemLinkData
func (ut *workItemLinkData) Publicize() *WorkItemLinkData {
	var pub WorkItemLinkData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a work item.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemLinkData struct {
	Attributes *WorkItemLinkAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemLinkRelationships `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string                     `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemLinkData type instance.
func (ut *WorkItemLinkData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "relationships"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemlinks") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemlinks"}))
	}
	return
}

// workItemLinkLinks user type.
type workItemLinkLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinkLinks type instance.
func (ut *workItemLinkLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemLinkLinks from workItemLinkLinks
func (ut *workItemLinkLinks) Publicize() *WorkItemLinkLinks {
	var pub WorkItemLinkLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinkLinks user type.
type WorkItemLinkLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinkLinks type instance.
func (ut *WorkItemLinkLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemLinkListMeta user type.
type workItemLinkListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemLinkListMeta type instance.
func (ut *workItemLinkListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	if ut.TotalCount != nil {
		if *ut.TotalCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.totalCount`, *ut.TotalCount, 0, true))
		}
	}
	return
}

// Publicize creates WorkItemLinkListMeta from workItemLinkListMeta
func (ut *workItemLinkListMeta) Publicize() *WorkItemLinkListMeta {
	var pub WorkItemLinkListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemLinkListMeta user type.
type WorkItemLinkListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Validate validates the WorkItemLinkListMeta type instance.
func (ut *WorkItemLinkListMeta) Validate() (err error) {
	if ut.TotalCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.totalCount`, ut.TotalCount, 0, true))
	}
	return
}

// JSONAPI store for the data of a work item link.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type workItemLinkRelationships struct {
	// The work item link type of this work item link.
	LinkType *relationWorkItemLinkType `form:"link_type,omitempty" json:"link_type,omitempty" xml:"link_type,omitempty"`
	// Work item where the connection starts.
	Source *relationWorkItem `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Work item where the connection ends.
	Target *relationWorkItem `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
}

// Validate validates the workItemLinkRelationships type instance.
func (ut *workItemLinkRelationships) Validate() (err error) {
	if ut.LinkType != nil {
		if err2 := ut.LinkType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Source != nil {
		if err2 := ut.Source.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Target != nil {
		if err2 := ut.Target.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemLinkRelationships from workItemLinkRelationships
func (ut *workItemLinkRelationships) Publicize() *WorkItemLinkRelationships {
	var pub WorkItemLinkRelationships
	if ut.LinkType != nil {
		pub.LinkType = ut.LinkType.Publicize()
	}
	if ut.Source != nil {
		pub.Source = ut.Source.Publicize()
	}
	if ut.Target != nil {
		pub.Target = ut.Target.Publicize()
	}
	return &pub
}

// JSONAPI store for the data of a work item link.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type WorkItemLinkRelationships struct {
	// The work item link type of this work item link.
	LinkType *RelationWorkItemLinkType `form:"link_type,omitempty" json:"link_type,omitempty" xml:"link_type,omitempty"`
	// Work item where the connection starts.
	Source *RelationWorkItem `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Work item where the connection ends.
	Target *RelationWorkItem `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
}

// Validate validates the WorkItemLinkRelationships type instance.
func (ut *WorkItemLinkRelationships) Validate() (err error) {
	if ut.LinkType != nil {
		if err2 := ut.LinkType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Source != nil {
		if err2 := ut.Source.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Target != nil {
		if err2 := ut.Target.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for all the "attributes" of a work item link type.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type workItemLinkTypeAttributes struct {
	// Time of creation of the given work item type
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the work item link type (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Description of forward name of the link type (optional)
	ForwardDescription *string `form:"forward_description,omitempty" json:"forward_description,omitempty" xml:"forward_description,omitempty"`
	// The forward oriented path from source to target is described with the forward name.
	// For example, if a bug blocks a user story, the forward name is "blocks". See also reverse name.
	ForwardName *string `form:"forward_name,omitempty" json:"forward_name,omitempty" xml:"forward_name,omitempty"`
	// Name of the work item link type (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of reverse name of the link type (optional)
	ReverseDescription *string `form:"reverse_description,omitempty" json:"reverse_description,omitempty" xml:"reverse_description,omitempty"`
	// The backwards oriented path from target to source is described with the reverse name.
	// For example, if a bug blocks a user story, the reverse name name is "blocked by" as in: a user story is blocked by a bug. See also forward name.
	ReverseName *string `form:"reverse_name,omitempty" json:"reverse_name,omitempty" xml:"reverse_name,omitempty"`
	// The topology determines the restrictions placed on the usage of each work item link type.
	Topology *string `form:"topology,omitempty" json:"topology,omitempty" xml:"topology,omitempty"`
	// Time of last update of the given work item type
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemLinkTypeAttributes type instance.
func (ut *workItemLinkTypeAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	if ut.Topology != nil {
		if !(*ut.Topology == "network" || *ut.Topology == "tree" || *ut.Topology == "dependency") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.topology`, *ut.Topology, []interface{}{"network", "tree", "dependency"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeAttributes from workItemLinkTypeAttributes
func (ut *workItemLinkTypeAttributes) Publicize() *WorkItemLinkTypeAttributes {
	var pub WorkItemLinkTypeAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.ForwardDescription != nil {
		pub.ForwardDescription = ut.ForwardDescription
	}
	if ut.ForwardName != nil {
		pub.ForwardName = ut.ForwardName
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.ReverseDescription != nil {
		pub.ReverseDescription = ut.ReverseDescription
	}
	if ut.ReverseName != nil {
		pub.ReverseName = ut.ReverseName
	}
	if ut.Topology != nil {
		pub.Topology = ut.Topology
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a work item link type.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkItemLinkTypeAttributes struct {
	// Time of creation of the given work item type
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the work item link type (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Description of forward name of the link type (optional)
	ForwardDescription *string `form:"forward_description,omitempty" json:"forward_description,omitempty" xml:"forward_description,omitempty"`
	// The forward oriented path from source to target is described with the forward name.
	// For example, if a bug blocks a user story, the forward name is "blocks". See also reverse name.
	ForwardName *string `form:"forward_name,omitempty" json:"forward_name,omitempty" xml:"forward_name,omitempty"`
	// Name of the work item link type (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of reverse name of the link type (optional)
	ReverseDescription *string `form:"reverse_description,omitempty" json:"reverse_description,omitempty" xml:"reverse_description,omitempty"`
	// The backwards oriented path from target to source is described with the reverse name.
	// For example, if a bug blocks a user story, the reverse name name is "blocked by" as in: a user story is blocked by a bug. See also forward name.
	ReverseName *string `form:"reverse_name,omitempty" json:"reverse_name,omitempty" xml:"reverse_name,omitempty"`
	// The topology determines the restrictions placed on the usage of each work item link type.
	Topology *string `form:"topology,omitempty" json:"topology,omitempty" xml:"topology,omitempty"`
	// Time of last update of the given work item type
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemLinkTypeAttributes type instance.
func (ut *WorkItemLinkTypeAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	if ut.Topology != nil {
		if !(*ut.Topology == "network" || *ut.Topology == "tree" || *ut.Topology == "dependency") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.topology`, *ut.Topology, []interface{}{"network", "tree", "dependency"}))
		}
	}
	return
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type workItemLinkTypeData struct {
	Attributes *workItemLinkTypeAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link type (optional during creation)
	ID            *uuid.UUID                     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks                  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemLinkTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                        `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemLinkTypeData type instance.
func (ut *workItemLinkTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinktypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemlinktypes"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeData from workItemLinkTypeData
func (ut *workItemLinkTypeData) Publicize() *WorkItemLinkTypeData {
	var pub WorkItemLinkTypeData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemLinkTypeData struct {
	Attributes *WorkItemLinkTypeAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of work item link type (optional during creation)
	ID            *uuid.UUID                     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks                  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemLinkTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                         `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemLinkTypeData type instance.
func (ut *WorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemlinktypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemlinktypes"}))
	}
	return
}

// workItemLinkTypeLinks user type.
type workItemLinkTypeLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinkTypeLinks type instance.
func (ut *workItemLinkTypeLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemLinkTypeLinks from workItemLinkTypeLinks
func (ut *workItemLinkTypeLinks) Publicize() *WorkItemLinkTypeLinks {
	var pub WorkItemLinkTypeLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinkTypeLinks user type.
type WorkItemLinkTypeLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinkTypeLinks type instance.
func (ut *WorkItemLinkTypeLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemLinkTypeListMeta user type.
type workItemLinkTypeListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemLinkTypeListMeta type instance.
func (ut *workItemLinkTypeListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	if ut.TotalCount != nil {
		if *ut.TotalCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`request.totalCount`, *ut.TotalCount, 0, true))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeListMeta from workItemLinkTypeListMeta
func (ut *workItemLinkTypeListMeta) Publicize() *WorkItemLinkTypeListMeta {
	var pub WorkItemLinkTypeListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemLinkTypeListMeta user type.
type WorkItemLinkTypeListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Validate validates the WorkItemLinkTypeListMeta type instance.
func (ut *WorkItemLinkTypeListMeta) Validate() (err error) {
	if ut.TotalCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`type.totalCount`, ut.TotalCount, 0, true))
	}
	return
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type workItemLinkTypeRelationships struct {
	// (OBSOLETE) This defines the owning space of this work item link type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the owning space template of this work item link type.
	SpaceTemplate *spaceTemplateRelation `form:"space_template,omitempty" json:"space_template,omitempty" xml:"space_template,omitempty"`
}

// Validate validates the workItemLinkTypeRelationships type instance.
func (ut *workItemLinkTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeRelationships from workItemLinkTypeRelationships
func (ut *workItemLinkTypeRelationships) Publicize() *WorkItemLinkTypeRelationships {
	var pub WorkItemLinkTypeRelationships
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.SpaceTemplate != nil {
		pub.SpaceTemplate = ut.SpaceTemplate.Publicize()
	}
	return &pub
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type WorkItemLinkTypeRelationships struct {
	// (OBSOLETE) This defines the owning space of this work item link type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the owning space template of this work item link type.
	SpaceTemplate *SpaceTemplateRelation `form:"space_template,omitempty" json:"space_template,omitempty" xml:"space_template,omitempty"`
}

// Validate validates the WorkItemLinkTypeRelationships type instance.
func (ut *WorkItemLinkTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// workItemLinks user type.
type workItemLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinks type instance.
func (ut *workItemLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemLinks from workItemLinks
func (ut *workItemLinks) Publicize() *WorkItemLinks {
	var pub WorkItemLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinks user type.
type WorkItemLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinks type instance.
func (ut *WorkItemLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemRelationships user type.
type workItemRelationships struct {
	// This defines the area this work item belongs to
	Area *relationGeneric `form:"area,omitempty" json:"area,omitempty" xml:"area,omitempty"`
	// This defines assignees of the Work Item
	Assignees *relationGenericList `form:"assignees,omitempty" json:"assignees,omitempty" xml:"assignees,omitempty"`
	// This defines type of Work Item
	BaseType *relationBaseType `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// This defines the children of this work item
	Children *relationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines comments on the Work Item
	Comments *relationGeneric `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// This defines creator of the Work Item
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// List of events in which this work item is involved
	Events *relationGeneric `form:"events,omitempty" json:"events,omitempty" xml:"events,omitempty"`
	// This defines the iteration this work item belong to
	Iteration *relationGeneric `form:"iteration,omitempty" json:"iteration,omitempty" xml:"iteration,omitempty"`
	// List of labels attached to the Work Item
	Labels *relationGenericList `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// This defines the parent of this work item.
	Parent *relationKindUUID `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space of this work item.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// List of board columns this Work Item is attached to
	SystemBoardcolumns *relationGenericList `form:"system.boardcolumns,omitempty" json:"system.boardcolumns,omitempty" xml:"system.boardcolumns,omitempty"`
	// List of links in which this work item is involved
	WorkItemLinks *relationGeneric `form:"workItemLinks,omitempty" json:"workItemLinks,omitempty" xml:"workItemLinks,omitempty"`
}

// Validate validates the workItemRelationships type instance.
func (ut *workItemRelationships) Validate() (err error) {
	if ut.BaseType != nil {
		if err2 := ut.BaseType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Parent != nil {
		if err2 := ut.Parent.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemRelationships from workItemRelationships
func (ut *workItemRelationships) Publicize() *WorkItemRelationships {
	var pub WorkItemRelationships
	if ut.Area != nil {
		pub.Area = ut.Area.Publicize()
	}
	if ut.Assignees != nil {
		pub.Assignees = ut.Assignees.Publicize()
	}
	if ut.BaseType != nil {
		pub.BaseType = ut.BaseType.Publicize()
	}
	if ut.Children != nil {
		pub.Children = ut.Children.Publicize()
	}
	if ut.Comments != nil {
		pub.Comments = ut.Comments.Publicize()
	}
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Events != nil {
		pub.Events = ut.Events.Publicize()
	}
	if ut.Iteration != nil {
		pub.Iteration = ut.Iteration.Publicize()
	}
	if ut.Labels != nil {
		pub.Labels = ut.Labels.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.SystemBoardcolumns != nil {
		pub.SystemBoardcolumns = ut.SystemBoardcolumns.Publicize()
	}
	if ut.WorkItemLinks != nil {
		pub.WorkItemLinks = ut.WorkItemLinks.Publicize()
	}
	return &pub
}

// WorkItemRelationships user type.
type WorkItemRelationships struct {
	// This defines the area this work item belongs to
	Area *RelationGeneric `form:"area,omitempty" json:"area,omitempty" xml:"area,omitempty"`
	// This defines assignees of the Work Item
	Assignees *RelationGenericList `form:"assignees,omitempty" json:"assignees,omitempty" xml:"assignees,omitempty"`
	// This defines type of Work Item
	BaseType *RelationBaseType `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// This defines the children of this work item
	Children *RelationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines comments on the Work Item
	Comments *RelationGeneric `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// This defines creator of the Work Item
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// List of events in which this work item is involved
	Events *RelationGeneric `form:"events,omitempty" json:"events,omitempty" xml:"events,omitempty"`
	// This defines the iteration this work item belong to
	Iteration *RelationGeneric `form:"iteration,omitempty" json:"iteration,omitempty" xml:"iteration,omitempty"`
	// List of labels attached to the Work Item
	Labels *RelationGenericList `form:"labels,omitempty" json:"labels,omitempty" xml:"labels,omitempty"`
	// This defines the parent of this work item.
	Parent *RelationKindUUID `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space of this work item.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// List of board columns this Work Item is attached to
	SystemBoardcolumns *RelationGenericList `form:"system.boardcolumns,omitempty" json:"system.boardcolumns,omitempty" xml:"system.boardcolumns,omitempty"`
	// List of links in which this work item is involved
	WorkItemLinks *RelationGeneric `form:"workItemLinks,omitempty" json:"workItemLinks,omitempty" xml:"workItemLinks,omitempty"`
}

// Validate validates the WorkItemRelationships type instance.
func (ut *WorkItemRelationships) Validate() (err error) {
	if ut.BaseType != nil {
		if err2 := ut.BaseType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Parent != nil {
		if err2 := ut.Parent.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// A work item type describes the values a work item type instance can hold.
type workItemTypeAttributes struct {
	// Whether or not this work item type is supposed to be used for creating work items directly.
	CanConstruct *bool `form:"can-construct,omitempty" json:"can-construct,omitempty" xml:"can-construct,omitempty"`
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// A human readable description for the work item type
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If newly created type extends any existing type (This is never present in any response and is only optional when creating.)
	ExtendedTypeName *uuid.UUID `form:"extendedTypeName,omitempty" json:"extendedTypeName,omitempty" xml:"extendedTypeName,omitempty"`
	// Definitions of fields in this work item type
	Fields map[string]*fieldDefinition `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	// CSS class string for an icon to use. See http://fontawesome.io/icons/ or http://www.patternfly.org/styles/icons/#_ for examples.
	Icon *string `form:"icon,omitempty" json:"icon,omitempty" xml:"icon,omitempty"`
	// The human readable name of the work item type
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemTypeAttributes type instance.
func (ut *workItemTypeAttributes) Validate() (err error) {
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "fields"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Icon == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "icon"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	for _, e := range ut.Fields {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if ut.Icon != nil {
		if utf8.RuneCountInString(*ut.Icon) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.icon`, *ut.Icon, utf8.RuneCountInString(*ut.Icon), 1, true))
		}
	}
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Publicize creates WorkItemTypeAttributes from workItemTypeAttributes
func (ut *workItemTypeAttributes) Publicize() *WorkItemTypeAttributes {
	var pub WorkItemTypeAttributes
	if ut.CanConstruct != nil {
		pub.CanConstruct = ut.CanConstruct
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.ExtendedTypeName != nil {
		pub.ExtendedTypeName = ut.ExtendedTypeName
	}
	if ut.Fields != nil {
		pub.Fields = make(map[string]*FieldDefinition, len(ut.Fields))
		for k2, v2 := range ut.Fields {
			pubk2 := k2
			var pubv2 *FieldDefinition
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Fields[pubk2] = pubv2
		}
	}
	if ut.Icon != nil {
		pub.Icon = *ut.Icon
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// A work item type describes the values a work item type instance can hold.
type WorkItemTypeAttributes struct {
	// Whether or not this work item type is supposed to be used for creating work items directly.
	CanConstruct *bool `form:"can-construct,omitempty" json:"can-construct,omitempty" xml:"can-construct,omitempty"`
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// A human readable description for the work item type
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If newly created type extends any existing type (This is never present in any response and is only optional when creating.)
	ExtendedTypeName *uuid.UUID `form:"extendedTypeName,omitempty" json:"extendedTypeName,omitempty" xml:"extendedTypeName,omitempty"`
	// Definitions of fields in this work item type
	Fields map[string]*FieldDefinition `form:"fields" json:"fields" xml:"fields"`
	// CSS class string for an icon to use. See http://fontawesome.io/icons/ or http://www.patternfly.org/styles/icons/#_ for examples.
	Icon string `form:"icon" json:"icon" xml:"icon"`
	// The human readable name of the work item type
	Name string `form:"name" json:"name" xml:"name"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemTypeAttributes type instance.
func (ut *WorkItemTypeAttributes) Validate() (err error) {
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "fields"))
	}
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Icon == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "icon"))
	}
	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	for _, e := range ut.Fields {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if utf8.RuneCountInString(ut.Icon) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.icon`, ut.Icon, utf8.RuneCountInString(ut.Icon), 1, true))
	}
	if ok := goa.ValidatePattern(`^[^_|-].*`, ut.Name); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, ut.Name, `^[^_|-].*`))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	if utf8.RuneCountInString(ut.Name) > 63 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 63, false))
	}
	return
}

// workItemTypeData user type.
type workItemTypeData struct {
	Attributes *workItemTypeAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item type (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemTypeData type instance.
func (ut *workItemTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "relationships"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates WorkItemTypeData from workItemTypeData
func (ut *workItemTypeData) Publicize() *WorkItemTypeData {
	var pub WorkItemTypeData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// WorkItemTypeData user type.
type WorkItemTypeData struct {
	Attributes *WorkItemTypeAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of work item type (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemTypeRelationships `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string                     `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemTypeData type instance.
func (ut *WorkItemTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "relationships"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// workItemTypeGroupAttributes user type.
type workItemTypeGroupAttributes struct {
	// Name of the bucket this group belongs to
	Bucket *string `form:"bucket,omitempty" json:"bucket,omitempty" xml:"bucket,omitempty"`
	// timestamp of entity creation
	CreatedAt   *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	Description *string    `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// CSS property value for icon of the group
	Icon *string `form:"icon,omitempty" json:"icon,omitempty" xml:"icon,omitempty"`
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Whether or not to render a link for this type group in the sidebar
	ShowInSidebar *bool `form:"show-in-sidebar,omitempty" json:"show-in-sidebar,omitempty" xml:"show-in-sidebar,omitempty"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Validate validates the workItemTypeGroupAttributes type instance.
func (ut *workItemTypeGroupAttributes) Validate() (err error) {
	if ut.Bucket == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "bucket"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Icon == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "icon"))
	}
	return
}

// Publicize creates WorkItemTypeGroupAttributes from workItemTypeGroupAttributes
func (ut *workItemTypeGroupAttributes) Publicize() *WorkItemTypeGroupAttributes {
	var pub WorkItemTypeGroupAttributes
	if ut.Bucket != nil {
		pub.Bucket = *ut.Bucket
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Icon != nil {
		pub.Icon = *ut.Icon
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.ShowInSidebar != nil {
		pub.ShowInSidebar = ut.ShowInSidebar
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	return &pub
}

// WorkItemTypeGroupAttributes user type.
type WorkItemTypeGroupAttributes struct {
	// Name of the bucket this group belongs to
	Bucket string `form:"bucket" json:"bucket" xml:"bucket"`
	// timestamp of entity creation
	CreatedAt   *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	Description *string    `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// CSS property value for icon of the group
	Icon string `form:"icon" json:"icon" xml:"icon"`
	Name string `form:"name" json:"name" xml:"name"`
	// Whether or not to render a link for this type group in the sidebar
	ShowInSidebar *bool `form:"show-in-sidebar,omitempty" json:"show-in-sidebar,omitempty" xml:"show-in-sidebar,omitempty"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Validate validates the WorkItemTypeGroupAttributes type instance.
func (ut *WorkItemTypeGroupAttributes) Validate() (err error) {
	if ut.Bucket == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "bucket"))
	}
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Icon == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "icon"))
	}
	return
}

// a type group bundles different work item type together
type workItemTypeGroupData struct {
	Attributes *workItemTypeGroupAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the work item type group
	ID            *uuid.UUID                      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks                   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemTypeGroupRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type string of the work item type group
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemTypeGroupData type instance.
func (ut *workItemTypeGroupData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypegroups") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workitemtypegroups"}))
		}
	}
	return
}

// Publicize creates WorkItemTypeGroupData from workItemTypeGroupData
func (ut *workItemTypeGroupData) Publicize() *WorkItemTypeGroupData {
	var pub WorkItemTypeGroupData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// a type group bundles different work item type together
type WorkItemTypeGroupData struct {
	Attributes *WorkItemTypeGroupAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the work item type group
	ID            *uuid.UUID                      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks                   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemTypeGroupRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type string of the work item type group
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemTypeGroupData type instance.
func (ut *WorkItemTypeGroupData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemtypegroups") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workitemtypegroups"}))
	}
	return
}

// workItemTypeGroupLinks user type.
type workItemTypeGroupLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemTypeGroupLinks type instance.
func (ut *workItemTypeGroupLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemTypeGroupLinks from workItemTypeGroupLinks
func (ut *workItemTypeGroupLinks) Publicize() *WorkItemTypeGroupLinks {
	var pub WorkItemTypeGroupLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemTypeGroupLinks user type.
type WorkItemTypeGroupLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemTypeGroupLinks type instance.
func (ut *WorkItemTypeGroupLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemTypeGroupRelationships user type.
type workItemTypeGroupRelationships struct {
	// The space template to which this group belongs
	SpaceTemplate *relationGeneric `form:"spaceTemplate,omitempty" json:"spaceTemplate,omitempty" xml:"spaceTemplate,omitempty"`
	// List of work item types attached to the type group
	TypeList *relationGenericList `form:"typeList,omitempty" json:"typeList,omitempty" xml:"typeList,omitempty"`
}

// Publicize creates WorkItemTypeGroupRelationships from workItemTypeGroupRelationships
func (ut *workItemTypeGroupRelationships) Publicize() *WorkItemTypeGroupRelationships {
	var pub WorkItemTypeGroupRelationships
	if ut.SpaceTemplate != nil {
		pub.SpaceTemplate = ut.SpaceTemplate.Publicize()
	}
	if ut.TypeList != nil {
		pub.TypeList = ut.TypeList.Publicize()
	}
	return &pub
}

// WorkItemTypeGroupRelationships user type.
type WorkItemTypeGroupRelationships struct {
	// The space template to which this group belongs
	SpaceTemplate *RelationGeneric `form:"spaceTemplate,omitempty" json:"spaceTemplate,omitempty" xml:"spaceTemplate,omitempty"`
	// List of work item types attached to the type group
	TypeList *RelationGenericList `form:"typeList,omitempty" json:"typeList,omitempty" xml:"typeList,omitempty"`
}

// workItemTypeLinks user type.
type workItemTypeLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemTypeLinks type instance.
func (ut *workItemTypeLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "self"))
	}
	return
}

// Publicize creates WorkItemTypeLinks from workItemTypeLinks
func (ut *workItemTypeLinks) Publicize() *WorkItemTypeLinks {
	var pub WorkItemTypeLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemTypeLinks user type.
type WorkItemTypeLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemTypeLinks type instance.
func (ut *WorkItemTypeLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "self"))
	}
	return
}

// workItemTypeListMeta user type.
type workItemTypeListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemTypeListMeta type instance.
func (ut *workItemTypeListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates WorkItemTypeListMeta from workItemTypeListMeta
func (ut *workItemTypeListMeta) Publicize() *WorkItemTypeListMeta {
	var pub WorkItemTypeListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemTypeListMeta user type.
type WorkItemTypeListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// workItemTypeRelationships user type.
type workItemTypeRelationships struct {
	// List of work item types that shall be proposed when creating a child of a work item of this type.
	GuidedChildTypes *relationGenericList `form:"guidedChildTypes,omitempty" json:"guidedChildTypes,omitempty" xml:"guidedChildTypes,omitempty"`
	// (OBSOLETE) This defines the owning space of this work item type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the owning space template of this work item type.
	SpaceTemplate *spaceTemplateRelation `form:"space_template,omitempty" json:"space_template,omitempty" xml:"space_template,omitempty"`
}

// Validate validates the workItemTypeRelationships type instance.
func (ut *workItemTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemTypeRelationships from workItemTypeRelationships
func (ut *workItemTypeRelationships) Publicize() *WorkItemTypeRelationships {
	var pub WorkItemTypeRelationships
	if ut.GuidedChildTypes != nil {
		pub.GuidedChildTypes = ut.GuidedChildTypes.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.SpaceTemplate != nil {
		pub.SpaceTemplate = ut.SpaceTemplate.Publicize()
	}
	return &pub
}

// WorkItemTypeRelationships user type.
type WorkItemTypeRelationships struct {
	// List of work item types that shall be proposed when creating a child of a work item of this type.
	GuidedChildTypes *RelationGenericList `form:"guidedChildTypes,omitempty" json:"guidedChildTypes,omitempty" xml:"guidedChildTypes,omitempty"`
	// (OBSOLETE) This defines the owning space of this work item type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the owning space template of this work item type.
	SpaceTemplate *SpaceTemplateRelation `form:"space_template,omitempty" json:"space_template,omitempty" xml:"space_template,omitempty"`
}

// Validate validates the WorkItemTypeRelationships type instance.
func (ut *WorkItemTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.SpaceTemplate != nil {
		if err2 := ut.SpaceTemplate.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for the data of a workspace.  See also http://jsonapi.org/format/#document-resource-object
type workspace struct {
	Attributes    *workspaceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links         *workspaceLinks      `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workspaceRelations  `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string              `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workspace type instance.
func (ut *workspace) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workspaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"workspaces"}))
		}
	}
	return
}

// Publicize creates Workspace from workspace
func (ut *workspace) Publicize() *Workspace {
	var pub Workspace
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a workspace.  See also http://jsonapi.org/format/#document-resource-object
type Workspace struct {
	Attributes    *WorkspaceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links         *WorkspaceLinks      `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkspaceRelations  `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string               `form:"type" json:"type" xml:"type"`
}

// Validate validates the Workspace type instance.
func (ut *Workspace) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if !(ut.Type == "workspaces") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"workspaces"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a workspace. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type workspaceAttributes struct {
	// The workspace description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The workspace id
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The workspace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The workspace status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// Publicize creates WorkspaceAttributes from workspaceAttributes
func (ut *workspaceAttributes) Publicize() *WorkspaceAttributes {
	var pub WorkspaceAttributes
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a workspace. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkspaceAttributes struct {
	// The workspace description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The workspace id
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The workspace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The workspace status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// workspaceEditLinks user type.
type workspaceEditLinks struct {
	Create *string `form:"create,omitempty" json:"create,omitempty" xml:"create,omitempty"`
}

// Publicize creates WorkspaceEditLinks from workspaceEditLinks
func (ut *workspaceEditLinks) Publicize() *WorkspaceEditLinks {
	var pub WorkspaceEditLinks
	if ut.Create != nil {
		pub.Create = ut.Create
	}
	return &pub
}

// WorkspaceEditLinks user type.
type WorkspaceEditLinks struct {
	Create *string `form:"create,omitempty" json:"create,omitempty" xml:"create,omitempty"`
}

// workspaceLinks user type.
type workspaceLinks struct {
	// The workspace 'ide' link
	Ide *string `form:"ide,omitempty" json:"ide,omitempty" xml:"ide,omitempty"`
	// The workspace 'open' link
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
	// The workspace 'self' link
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates WorkspaceLinks from workspaceLinks
func (ut *workspaceLinks) Publicize() *WorkspaceLinks {
	var pub WorkspaceLinks
	if ut.Ide != nil {
		pub.Ide = ut.Ide
	}
	if ut.Open != nil {
		pub.Open = ut.Open
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// WorkspaceLinks user type.
type WorkspaceLinks struct {
	// The workspace 'ide' link
	Ide *string `form:"ide,omitempty" json:"ide,omitempty" xml:"ide,omitempty"`
	// The workspace 'open' link
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
	// The workspace 'self' link
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// workspaceOpenLinks user type.
type workspaceOpenLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// Publicize creates WorkspaceOpenLinks from workspaceOpenLinks
func (ut *workspaceOpenLinks) Publicize() *WorkspaceOpenLinks {
	var pub WorkspaceOpenLinks
	if ut.Open != nil {
		pub.Open = ut.Open
	}
	return &pub
}

// WorkspaceOpenLinks user type.
type WorkspaceOpenLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// workspaceRelations user type.
type workspaceRelations struct {
	// This defines the owning codebase
	Codebase *relationGeneric `form:"codebase,omitempty" json:"codebase,omitempty" xml:"codebase,omitempty"`
}

// Publicize creates WorkspaceRelations from workspaceRelations
func (ut *workspaceRelations) Publicize() *WorkspaceRelations {
	var pub WorkspaceRelations
	if ut.Codebase != nil {
		pub.Codebase = ut.Codebase.Publicize()
	}
	return &pub
}

// WorkspaceRelations user type.
type WorkspaceRelations struct {
	// This defines the owning codebase
	Codebase *RelationGeneric `form:"codebase,omitempty" json:"codebase,omitempty" xml:"codebase,omitempty"`
}

// A fieldDefinition aggregates a fieldType and additional field metadata
type fieldDefinition struct {
	// A description for the field
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// A label for the field that is shown in the UI
	Label    *string    `form:"label,omitempty" json:"label,omitempty" xml:"label,omitempty"`
	Required *bool      `form:"required,omitempty" json:"required,omitempty" xml:"required,omitempty"`
	Type     *fieldType `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the fieldDefinition type instance.
func (ut *fieldDefinition) Validate() (err error) {
	if ut.Required == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "required"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Label == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "label"))
	}
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "description"))
	}
	if ut.Description != nil {
		if utf8.RuneCountInString(*ut.Description) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.description`, *ut.Description, utf8.RuneCountInString(*ut.Description), 1, true))
		}
	}
	if ut.Label != nil {
		if utf8.RuneCountInString(*ut.Label) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.label`, *ut.Label, utf8.RuneCountInString(*ut.Label), 1, true))
		}
	}
	if ut.Type != nil {
		if err2 := ut.Type.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates FieldDefinition from fieldDefinition
func (ut *fieldDefinition) Publicize() *FieldDefinition {
	var pub FieldDefinition
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.Label != nil {
		pub.Label = *ut.Label
	}
	if ut.Required != nil {
		pub.Required = *ut.Required
	}
	if ut.Type != nil {
		pub.Type = ut.Type.Publicize()
	}
	return &pub
}

// A fieldDefinition aggregates a fieldType and additional field metadata
type FieldDefinition struct {
	// A description for the field
	Description string `form:"description" json:"description" xml:"description"`
	// A label for the field that is shown in the UI
	Label    string     `form:"label" json:"label" xml:"label"`
	Required bool       `form:"required" json:"required" xml:"required"`
	Type     *FieldType `form:"type" json:"type" xml:"type"`
}

// Validate validates the FieldDefinition type instance.
func (ut *FieldDefinition) Validate() (err error) {

	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Label == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "label"))
	}
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "description"))
	}
	if utf8.RuneCountInString(ut.Description) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.description`, ut.Description, utf8.RuneCountInString(ut.Description), 1, true))
	}
	if utf8.RuneCountInString(ut.Label) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.label`, ut.Label, utf8.RuneCountInString(ut.Label), 1, true))
	}
	if ut.Type != nil {
		if err2 := ut.Type.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// A fieldType describes the values a particular field can hold
type fieldType struct {
	// The kind of type of the enumeration values for an enum type. Required for enum types. Must be a simple type, not  enum or list
	BaseType *string `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// The kind of type of the individual elements for a list type. Required for list types. Must be a simple type, not  enum or list
	ComponentType *string `form:"componentType,omitempty" json:"componentType,omitempty" xml:"componentType,omitempty"`
	// Optional default value (if any)
	DefaultValue *interface{} `form:"defaultValue,omitempty" json:"defaultValue,omitempty" xml:"defaultValue,omitempty"`
	// The constant indicating the kind of type, for example 'string' or 'enum' or 'instant'
	Kind *string `form:"kind,omitempty" json:"kind,omitempty" xml:"kind,omitempty"`
	// The possible values for an enum type. The values must be of a type convertible to the base type
	Values []interface{} `form:"values,omitempty" json:"values,omitempty" xml:"values,omitempty"`
}

// Validate validates the fieldType type instance.
func (ut *fieldType) Validate() (err error) {
	if ut.Kind == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "kind"))
	}
	return
}

// Publicize creates FieldType from fieldType
func (ut *fieldType) Publicize() *FieldType {
	var pub FieldType
	if ut.BaseType != nil {
		pub.BaseType = ut.BaseType
	}
	if ut.ComponentType != nil {
		pub.ComponentType = ut.ComponentType
	}
	if ut.DefaultValue != nil {
		pub.DefaultValue = ut.DefaultValue
	}
	if ut.Kind != nil {
		pub.Kind = *ut.Kind
	}
	if ut.Values != nil {
		pub.Values = ut.Values
	}
	return &pub
}

// A fieldType describes the values a particular field can hold
type FieldType struct {
	// The kind of type of the enumeration values for an enum type. Required for enum types. Must be a simple type, not  enum or list
	BaseType *string `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// The kind of type of the individual elements for a list type. Required for list types. Must be a simple type, not  enum or list
	ComponentType *string `form:"componentType,omitempty" json:"componentType,omitempty" xml:"componentType,omitempty"`
	// Optional default value (if any)
	DefaultValue *interface{} `form:"defaultValue,omitempty" json:"defaultValue,omitempty" xml:"defaultValue,omitempty"`
	// The constant indicating the kind of type, for example 'string' or 'enum' or 'instant'
	Kind string `form:"kind" json:"kind" xml:"kind"`
	// The possible values for an enum type. The values must be of a type convertible to the base type
	Values []interface{} `form:"values,omitempty" json:"values,omitempty" xml:"values,omitempty"`
}

// Validate validates the FieldType type instance.
func (ut *FieldType) Validate() (err error) {
	if ut.Kind == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "kind"))
	}
	return
}

// JSONAPI store for all the "attributes" of a filter. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type filterAttributes struct {
	// When the filter was created
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Filter key to be used in the search query language
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Query *string `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	// The Filter name
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Path to the topmost parent
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the filterAttributes type instance.
func (ut *filterAttributes) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Title == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "title"))
	}
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "description"))
	}
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "query"))
	}
	if ut.Key == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "key"))
	}
	return
}

// Publicize creates FilterAttributes from filterAttributes
func (ut *filterAttributes) Publicize() *FilterAttributes {
	var pub FilterAttributes
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.Key != nil {
		pub.Key = *ut.Key
	}
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Title != nil {
		pub.Title = *ut.Title
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a filter. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type FilterAttributes struct {
	// When the filter was created
	Description string `form:"description" json:"description" xml:"description"`
	// Filter key to be used in the search query language
	Key string `form:"key" json:"key" xml:"key"`
	// Version for optimistic concurrency control (optional during creating)
	Query string `form:"query" json:"query" xml:"query"`
	// The Filter name
	Title string `form:"title" json:"title" xml:"title"`
	// Path to the topmost parent
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the FilterAttributes type instance.
func (ut *FilterAttributes) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "title"))
	}
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "description"))
	}
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "query"))
	}
	if ut.Key == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "key"))
	}
	return
}

// JSONAPI store for the data of a filter. See also http://jsonapi.org/format/#document-resource-object
type filters struct {
	Attributes *filterAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Type       *string           `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the filters type instance.
func (ut *filters) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "filters") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"filters"}))
		}
	}
	return
}

// Publicize creates Filters from filters
func (ut *filters) Publicize() *Filters {
	var pub Filters
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a filter. See also http://jsonapi.org/format/#document-resource-object
type Filters struct {
	Attributes *FilterAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Type       string            `form:"type" json:"type" xml:"type"`
}

// Validate validates the Filters type instance.
func (ut *Filters) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "filters") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"filters"}))
	}
	return
}

// pagingLinks user type.
type pagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// Publicize creates PagingLinks from pagingLinks
func (ut *pagingLinks) Publicize() *PagingLinks {
	var pub PagingLinks
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.First != nil {
		pub.First = ut.First
	}
	if ut.Last != nil {
		pub.Last = ut.Last
	}
	if ut.Next != nil {
		pub.Next = ut.Next
	}
	if ut.Prev != nil {
		pub.Prev = ut.Prev
	}
	return &pub
}

// PagingLinks user type.
type PagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// workItemListResponseMeta user type.
type workItemListResponseMeta struct {
	// array of work item IDs in the "included" array that are ancestors
	AncestorIDs []uuid.UUID `form:"ancestorIDs,omitempty" json:"ancestorIDs,omitempty" xml:"ancestorIDs,omitempty"`
	TotalCount  *int        `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemListResponseMeta type instance.
func (ut *workItemListResponseMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "totalCount"))
	}
	return
}

// Publicize creates WorkItemListResponseMeta from workItemListResponseMeta
func (ut *workItemListResponseMeta) Publicize() *WorkItemListResponseMeta {
	var pub WorkItemListResponseMeta
	if ut.AncestorIDs != nil {
		pub.AncestorIDs = ut.AncestorIDs
	}
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemListResponseMeta user type.
type WorkItemListResponseMeta struct {
	// array of work item IDs in the "included" array that are ancestors
	AncestorIDs []uuid.UUID `form:"ancestorIDs,omitempty" json:"ancestorIDs,omitempty" xml:"ancestorIDs,omitempty"`
	TotalCount  int         `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Position represents the ID of the workitem above which the to-be-reordered workitem(s) should be placed
type workItemReorderPosition struct {
	// Direction of the place of the reorder workitem. Above should be used to place the reorder workitem(s) above workitem with id equal to position.id. Below should be used to place the reorder workitem(s) below workitem with id equal to position.id. Top places the reorder workitem(s) at the Topmost position of the list. Bottom places the reorder item(s) at the bottom of the list.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty" xml:"direction,omitempty"`
	// ID of the workitem above which the to-be-reordered workitem(s) should be placed
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the workItemReorderPosition type instance.
func (ut *workItemReorderPosition) Validate() (err error) {
	if ut.Direction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "direction"))
	}
	if ut.Direction != nil {
		if !(*ut.Direction == "above" || *ut.Direction == "below" || *ut.Direction == "top" || *ut.Direction == "bottom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.direction`, *ut.Direction, []interface{}{"above", "below", "top", "bottom"}))
		}
	}
	return
}

// Publicize creates WorkItemReorderPosition from workItemReorderPosition
func (ut *workItemReorderPosition) Publicize() *WorkItemReorderPosition {
	var pub WorkItemReorderPosition
	if ut.Direction != nil {
		pub.Direction = *ut.Direction
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	return &pub
}

// Position represents the ID of the workitem above which the to-be-reordered workitem(s) should be placed
type WorkItemReorderPosition struct {
	// Direction of the place of the reorder workitem. Above should be used to place the reorder workitem(s) above workitem with id equal to position.id. Below should be used to place the reorder workitem(s) below workitem with id equal to position.id. Top places the reorder workitem(s) at the Topmost position of the list. Bottom places the reorder item(s) at the bottom of the list.
	Direction string `form:"direction" json:"direction" xml:"direction"`
	// ID of the workitem above which the to-be-reordered workitem(s) should be placed
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the WorkItemReorderPosition type instance.
func (ut *WorkItemReorderPosition) Validate() (err error) {
	if ut.Direction == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "direction"))
	}
	if !(ut.Direction == "above" || ut.Direction == "below" || ut.Direction == "top" || ut.Direction == "bottom") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.direction`, ut.Direction, []interface{}{"above", "below", "top", "bottom"}))
	}
	return
}
